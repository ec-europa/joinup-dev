diff --git a/CHANGELOG.txt b/CHANGELOG.txt
index 7641ab8f..7d159590 100644
--- a/CHANGELOG.txt
+++ b/CHANGELOG.txt
@@ -1,3 +1,18 @@
+Search API 1.x, dev (xxxx-xx-xx):
+---------------------------------
+- #2986222 by idebr, drunken monkey: Switched Javascript tests to
+  WebDriverTestBase.
+- #2840272 by drunken monkey: Fixed fatal error in certain Views error
+  conditions.
+- #3057510 by drunken monkey, borisson_: Fixed inconsistent package names for
+  test modules.
+- #3031621 by drunken monkey, DeFr, borisson_: Fixed fields returned by backend
+  sometimes ignored by Views.
+- #3053603 by drunken monkey, borisson_: Fixed reported cardinality of
+  entity-valued processor properties.
+- #2881689 by pwolanin, drunken monkey, borisson_: Added performance
+  improvement for initial tracking of existing entities.
+
 Search API 1.13 (2019-05-07):
 -----------------------------
 - #3043930 by kfritsche, drunken monkey, borisson_: Fixed issue with nested
diff --git a/modules/search_api_db/tests/search_api_db_test_autocomplete/search_api_db_test_autocomplete.info.yml b/modules/search_api_db/tests/search_api_db_test_autocomplete/search_api_db_test_autocomplete.info.yml
index 2cff21ab..311539a6 100644
--- a/modules/search_api_db/tests/search_api_db_test_autocomplete/search_api_db_test_autocomplete.info.yml
+++ b/modules/search_api_db/tests/search_api_db_test_autocomplete/search_api_db_test_autocomplete.info.yml
@@ -1,7 +1,7 @@
 name: 'Search API Database Autocomplete Test'
 type: module
 description: 'Support module for testing Autocomplete support of the "Database" backend'
-package: Search
+package: Testing
 dependencies:
   - search_api:search_api_test_views
   - search_api_autocomplete:search_api_autocomplete
diff --git a/modules/search_api_db/tests/src/FunctionalJavascript/IntegrationTest.php b/modules/search_api_db/tests/src/FunctionalJavascript/IntegrationTest.php
index 3c629a38..8e2046c2 100644
--- a/modules/search_api_db/tests/src/FunctionalJavascript/IntegrationTest.php
+++ b/modules/search_api_db/tests/src/FunctionalJavascript/IntegrationTest.php
@@ -2,17 +2,14 @@
 
 namespace Drupal\Tests\search_api_db\FunctionalJavascript;
 
-use Drupal\Core\StringTranslation\StringTranslationTrait;
-use Drupal\FunctionalJavascriptTests\JavascriptTestBase;
+use Drupal\FunctionalJavascriptTests\WebDriverTestBase;
 
 /**
  * Tests that using the DB backend via the UI works as expected.
  *
  * @group search_api
  */
-class IntegrationTest extends JavascriptTestBase {
-
-  use StringTranslationTrait;
+class IntegrationTest extends WebDriverTestBase {
 
   /**
    * {@inheritdoc}
@@ -26,15 +23,22 @@ class IntegrationTest extends JavascriptTestBase {
    * Tests that adding a server works.
    */
   public function testAddingServer() {
-    $admin_user = $this->drupalCreateUser(['administer search_api', 'access administration pages']);
+    $admin_user = $this->drupalCreateUser(['administer search_api', 'access content']);
     $this->drupalLogin($admin_user);
 
     $this->drupalGet('admin/config/search/search-api/add-server');
-    $this->assertSession()->statusCodeEquals(200);
-
-    $edit = ['name' => ' ~`Test Server', 'id' => '_test'];
-    $this->submitForm($edit, 'Save');
-    $this->assertSession()->addressEquals('admin/config/search/search-api/server/_test');
+    $page = $this->getSession()->getPage();
+    $assert_session = $this->assertSession();
+    $assert_session->pageTextContains('Add search server');
+
+    $page->fillField('name', ' ~`Test Server');
+    $machine_name = $assert_session->waitForElementVisible('css', '[name="name"] + * .machine-name-value');
+    $this->assertNotEmpty($machine_name);
+    $page->findButton('Edit')->press();
+    $page->fillField('id', '_test');
+    $page->pressButton('Save');
+
+    $assert_session->addressEquals('admin/config/search/search-api/server/_test');
   }
 
 }
diff --git a/search_api.views.inc b/search_api.views.inc
index f47fc123..2426375c 100644
--- a/search_api.views.inc
+++ b/search_api.views.inc
@@ -417,7 +417,7 @@ function _search_api_views_data_special_fields(array &$table, IndexInterface $in
 
   $datasource_field = _search_api_views_find_field_alias('search_api_datasource', $table);
   $table[$datasource_field]['title'] = t('Datasource');
-  $table[$datasource_field]['help'] = t("The data source ID");
+  $table[$datasource_field]['help'] = t('The datasource ID');
   $table[$datasource_field]['argument']['id'] = 'search_api';
   $table[$datasource_field]['argument']['disable_break_phrase'] = TRUE;
   $table[$datasource_field]['field']['id'] = 'standard';
diff --git a/src/Datasource/DatasourceInterface.php b/src/Datasource/DatasourceInterface.php
index 5cd4ed1a..5148f24a 100644
--- a/src/Datasource/DatasourceInterface.php
+++ b/src/Datasource/DatasourceInterface.php
@@ -238,4 +238,19 @@ interface DatasourceInterface extends IndexPluginInterface {
    */
   public function getFieldDependencies(array $fields);
 
+  /**
+   * Returns the list cache contexts associated with this datasource.
+   *
+   * List cache contexts ensure that if items from a datasource are included in
+   * a list that any caches containing this list are varied as necessary. For
+   * example a View might contain a number of items from this data source that
+   * are visible only by users that have a certain role. These list cache
+   * contexts will ensure that separate cached versions exists for users with
+   * this role and without it. They should be included whenever a list is
+   * rendered that contains items from this datasource.
+   *
+   * @return string[]
+   */
+  public function getListCacheContexts();
+
 }
diff --git a/src/Datasource/DatasourcePluginBase.php b/src/Datasource/DatasourcePluginBase.php
index e6cfea03..5cc1391f 100644
--- a/src/Datasource/DatasourcePluginBase.php
+++ b/src/Datasource/DatasourcePluginBase.php
@@ -155,4 +155,11 @@ abstract class DatasourcePluginBase extends IndexPluginBase implements Datasourc
     return [];
   }
 
+  /**
+   * {@inheritdoc}
+   */
+  public function getListCacheContexts() {
+    return [];
+  }
+
 }
diff --git a/src/Entity/Index.php b/src/Entity/Index.php
index 7765e079..5c64000f 100644
--- a/src/Entity/Index.php
+++ b/src/Entity/Index.php
@@ -1184,6 +1184,18 @@ class Index extends ConfigEntityBase implements IndexInterface {
       ->createQuery($this, $options);
   }
 
+  /**
+   * {@inheritdoc}
+   */
+  public function getCacheTagsToInvalidate() {
+    // Whenever this entity changes we need to invalidate all caches tagged with
+    // the config entity, and also all listings that contain results from this
+    // index.
+    return array_merge(parent::getCacheTagsToInvalidate(), [
+      'search_api_list:' . $this->id(),
+    ]);
+  }
+
   /**
    * {@inheritdoc}
    */
diff --git a/src/Form/IndexForm.php b/src/Form/IndexForm.php
index 5615fd99..16e3d068 100644
--- a/src/Form/IndexForm.php
+++ b/src/Form/IndexForm.php
@@ -169,8 +169,8 @@ class IndexForm extends EntityForm {
 
     $form['datasources'] = [
       '#type' => 'checkboxes',
-      '#title' => $this->t('Data sources'),
-      '#description' => $this->t('Select one or more data sources of items that will be stored in this index.'),
+      '#title' => $this->t('Datasources'),
+      '#description' => $this->t('Select one or more datasources of items that will be stored in this index.'),
       '#default_value' => $index->getDatasourceIds(),
       '#multiple' => TRUE,
       '#required' => TRUE,
diff --git a/src/Plugin/search_api/datasource/ContentEntity.php b/src/Plugin/search_api/datasource/ContentEntity.php
index 6224ce31..c7694791 100644
--- a/src/Plugin/search_api/datasource/ContentEntity.php
+++ b/src/Plugin/search_api/datasource/ContentEntity.php
@@ -2,6 +2,9 @@
 
 namespace Drupal\search_api\Plugin\search_api\datasource;
 
+use Drupal\Component\Utility\Crypt;
+use Drupal\Core\Cache\Cache;
+use Drupal\Core\Cache\CacheBackendInterface;
 use Drupal\Core\Config\ConfigFactoryInterface;
 use Drupal\Core\Entity\ContentEntityInterface;
 use Drupal\Core\Entity\EntityDisplayRepositoryInterface;
@@ -16,6 +19,7 @@ use Drupal\Core\Language\LanguageInterface;
 use Drupal\Core\Language\LanguageManagerInterface;
 use Drupal\Core\Plugin\PluginFormInterface;
 use Drupal\Core\Session\AccountInterface;
+use Drupal\Core\State\StateInterface;
 use Drupal\Core\TypedData\ComplexDataDefinitionInterface;
 use Drupal\Core\TypedData\ComplexDataInterface;
 use Drupal\Core\TypedData\TypedDataManagerInterface;
@@ -41,6 +45,27 @@ class ContentEntity extends DatasourcePluginBase implements EntityDatasourceInte
 
   use PluginFormTrait;
 
+  /**
+   * The key for accessing last tracked ID information in site state.
+   *
+   * @todo Make protected once we depend on PHP 7.1+.
+   */
+  const TRACKING_PAGE_STATE_KEY = 'search_api.datasource.entity.last_ids';
+
+  /**
+   * The entity memory cache.
+   *
+   * @var \Drupal\Core\Cache\CacheBackendInterface
+   */
+  protected $memoryCache;
+
+  /**
+   * The state service.
+   *
+   * @var \Drupal\Core\State\StateInterface
+   */
+  protected $state;
+
   /**
    * The entity type manager.
    *
@@ -129,6 +154,12 @@ class ContentEntity extends DatasourcePluginBase implements EntityDatasourceInte
     $datasource->setConfigFactory($container->get('config.factory'));
     $datasource->setLanguageManager($container->get('language_manager'));
     $datasource->setFieldsHelper($container->get('search_api.fields_helper'));
+    $datasource->setState($container->get('state'));
+    // This service was added in 8.6.x.
+    // @todo Remove the "if" once we depend on Drupal 8.6+.
+    if ($container->has('entity.memory_cache')) {
+      $datasource->setEntityMemoryCache($container->get('entity.memory_cache'));
+    }
 
     return $datasource;
   }
@@ -348,6 +379,52 @@ class ContentEntity extends DatasourcePluginBase implements EntityDatasourceInte
     return $this;
   }
 
+  /**
+   * Retrieves the state service.
+   *
+   * @return \Drupal\Core\State\StateInterface
+   *   The entity type manager.
+   */
+  public function getState() {
+    return $this->state ?: \Drupal::state();
+  }
+
+  /**
+   * Sets the state service.
+   *
+   * @param \Drupal\Core\State\StateInterface $state
+   *   The state service.
+   *
+   * @return $this
+   */
+  public function setState(StateInterface $state) {
+    $this->state = $state;
+    return $this;
+  }
+
+  /**
+   * Retrieves the entity memory cache service.
+   *
+   * @return \Drupal\Core\Cache\CacheBackendInterface|null
+   *   The memory cache, or NULL.
+   */
+  public function getEntityMemoryCache() {
+    return $this->memoryCache;
+  }
+
+  /**
+   * Sets the entity memory cache service.
+   *
+   * @param \Drupal\Core\Cache\CacheBackendInterface $memory_cache
+   *   The memory cache.
+   *
+   * @return $this
+   */
+  public function setEntityMemoryCache(CacheBackendInterface $memory_cache) {
+    $this->memoryCache = $memory_cache;
+    return $this;
+  }
+
   /**
    * {@inheritdoc}
    */
@@ -680,6 +757,17 @@ class ContentEntity extends DatasourcePluginBase implements EntityDatasourceInte
     // When tracking items, we never want access checks.
     $select->accessCheck(FALSE);
 
+    // Build up the context for tracking the last ID for this batch page.
+    $batch_page_context = [
+      'index_id' => $this->getIndex()->id(),
+      // The derivative plugin ID includes the entity type ID.
+      'datasource_id' => $this->getPluginId(),
+      'bundles' => $bundles,
+      'languages' => $languages,
+    ];
+    $context_key = Crypt::hashBase64(serialize($batch_page_context));
+    $last_ids = $this->getState()->get(self::TRACKING_PAGE_STATE_KEY, []);
+
     // We want to determine all entities of either one of the given bundles OR
     // one of the given languages. That means we can't just filter for $bundles
     // if $languages is given. Instead, we have to filter for all bundles we
@@ -707,18 +795,49 @@ class ContentEntity extends DatasourcePluginBase implements EntityDatasourceInte
     if (isset($page)) {
       $page_size = $this->getConfigValue('tracking_page_size');
       assert($page_size, 'Tracking page size is not set.');
-      $select->range($page * $page_size, $page_size);
-      // For paging to reliably work, a sort should be present.
       $entity_id = $this->getEntityType()->getKey('id');
+
+      // If known, use a condition on the last tracked ID for paging instead of
+      // the offset, for performance reasons on large sites.
+      $offset = $page * $page_size;
+      if ($page > 0) {
+        // We only handle the case of picking up from where the last page left
+        // off. (This will cause an infinite loop if anyone ever wants to index
+        // Search API tasks in an index, so check for that to be on the safe
+        // side.)
+        if (isset($last_ids[$context_key])
+            && $last_ids[$context_key]['page'] == ($page - 1)
+            && $this->getEntityTypeId() !== 'search_api_task') {
+          $select->condition($entity_id, $last_ids[$context_key]['last_id'], '>');
+          $offset = 0;
+        }
+      }
+      $select->range($offset, $page_size);
+
+      // For paging to reliably work, a sort should be present.
       $select->sort($entity_id);
     }
 
     $entity_ids = $select->execute();
 
     if (!$entity_ids) {
+      if (isset($page)) {
+        // Clean up state tracking of last ID.
+        unset($last_ids[$context_key]);
+        $this->getState()->set(self::TRACKING_PAGE_STATE_KEY, $last_ids);
+      }
       return NULL;
     }
 
+    // Remember the last tracked ID for the next call.
+    if (isset($page)) {
+      $last_ids[$context_key] = [
+        'page' => (int) $page,
+        'last_id' => end($entity_ids),
+      ];
+      $this->getState()->set(self::TRACKING_PAGE_STATE_KEY, $last_ids);
+    }
+
     // For all loaded entities, compute all their item IDs (one for each
     // translation we want to include). For those matching the given bundles (if
     // any), we want to include translations for all enabled languages. For all
@@ -754,7 +873,15 @@ class ContentEntity extends DatasourcePluginBase implements EntityDatasourceInte
       // When running in the CLI, this might be executed for all entities from
       // within a single process. To avoid running out of memory, reset the
       // static cache after each batch.
-      $this->getEntityStorage()->resetCache($entity_ids);
+      $memory_cache = $this->getEntityMemoryCache();
+      if ($memory_cache) {
+        $memory_cache->deleteAll();
+      }
+      else {
+        // Fallback for Drupal 8.5.x.
+        // @todo Remove this once we depend on Drupal 8.6+.
+        $this->getEntityStorage()->resetCache($entity_ids);
+      }
     }
 
     return $item_ids;
@@ -1043,4 +1170,12 @@ class ContentEntity extends DatasourcePluginBase implements EntityDatasourceInte
     return $valid_ids;
   }
 
+  /**
+   * {@inheritdoc}
+   */
+  public function getListCacheContexts() {
+    $contexts = parent::getListCacheContexts();
+    return Cache::mergeContexts($this->getEntityType()->getListCacheContexts(), $contexts);
+  }
+
 }
diff --git a/src/Plugin/views/cache/SearchApiCachePluginTrait.php b/src/Plugin/views/cache/SearchApiCachePluginTrait.php
index 9f6e7100..6e056206 100644
--- a/src/Plugin/views/cache/SearchApiCachePluginTrait.php
+++ b/src/Plugin/views/cache/SearchApiCachePluginTrait.php
@@ -4,6 +4,7 @@ namespace Drupal\search_api\Plugin\views\cache;
 
 use Drupal\Component\Utility\Crypt;
 use Drupal\Core\Cache\Cache;
+use Drupal\Core\Cache\CacheableDependencyInterface;
 use Drupal\Core\Cache\CacheBackendInterface;
 use Drupal\Core\Cache\Context\CacheContextsManager;
 use Drupal\search_api\Plugin\views\query\SearchApiQuery;
@@ -188,6 +189,9 @@ trait SearchApiCachePluginTrait {
         ],
       ];
 
+      // Vary the results key by the cache contexts of the display handler.
+      // These cache contexts are calculated when the view is saved in the Views
+      // UI and stored in the view config entity.
       $display_handler_cache_contexts = $this->displayHandler
         ->getCacheMetadata()
         ->getCacheContexts();
diff --git a/src/Plugin/views/cache/SearchApiTagCache.php b/src/Plugin/views/cache/SearchApiTagCache.php
index 48e7728f..4f7c0f58 100644
--- a/src/Plugin/views/cache/SearchApiTagCache.php
+++ b/src/Plugin/views/cache/SearchApiTagCache.php
@@ -3,6 +3,7 @@
 namespace Drupal\search_api\Plugin\views\cache;
 
 use Drupal\Core\Cache\Cache;
+use Drupal\Core\Cache\CacheableMetadata;
 use Drupal\Core\Entity\EntityInterface;
 use Drupal\Core\Entity\EntityTypeManagerInterface;
 use Drupal\views\Plugin\views\cache\Tag;
@@ -17,7 +18,7 @@ use Symfony\Component\DependencyInjection\ContainerInterface;
  *
  * Use this for search results views that are fully controlled by a single
  * Drupal instance. A common use case is a website that uses the default
- * database search backend and does not index any external data sources.
+ * database search backend and does not index any external datasources.
  *
  * @ingroup views_cache_plugins
  *
@@ -78,8 +79,10 @@ class SearchApiTagCache extends Tag {
    */
   public function getCacheTags() {
     $tags = $this->view->storage->getCacheTags();
-    $tag = 'search_api_list:' . $this->getQuery()->getIndex()->id();
-    $tags = Cache::mergeTags([$tag], $tags);
+    // Add the cache tags of the search index, so that the view will be
+    // invalidated whenever the index changes or its contents are updated.
+    $index_tags = $this->getQuery()->getIndex()->getCacheTagsToInvalidate();
+    $tags = Cache::mergeTags($index_tags, $tags);
     return $tags;
   }
 
@@ -109,4 +112,15 @@ class SearchApiTagCache extends Tag {
     return $tags;
   }
 
+  /**
+   * {@inheritdoc}
+   */
+  public function alterCacheMetadata(CacheableMetadata $cache_metadata) {
+    // Allow modules that alter the query to add their cache metadata to the
+    // view.
+    $query = $this->getQuery()->getSearchApiQuery();
+    $query->preExecute();
+    $cache_metadata->addCacheableDependency($query);
+  }
+
 }
diff --git a/src/Plugin/views/cache/SearchApiTimeCache.php b/src/Plugin/views/cache/SearchApiTimeCache.php
index 8a3e7b95..4010c644 100644
--- a/src/Plugin/views/cache/SearchApiTimeCache.php
+++ b/src/Plugin/views/cache/SearchApiTimeCache.php
@@ -21,7 +21,7 @@ use Drupal\views\Plugin\views\cache\Time;
  * @ViewsCache(
  *   id = "search_api_time",
  *   title = @Translation("Search API (time-based)"),
- *   help = @Translation("Cache results for a predefined time period. Useful for sites that use external search engines such as Solr, or index multiple data sources. <strong>Caution:</strong> Will lead to stale results and might harm performance for complex search pages.")
+ *   help = @Translation("Cache results for a predefined time period. Useful for sites that use external search engines such as Solr, or index multiple datasources. <strong>Caution:</strong> Will lead to stale results and might harm performance for complex search pages.")
  * )
  */
 class SearchApiTimeCache extends Time {
diff --git a/src/Plugin/views/field/SearchApiFieldTrait.php b/src/Plugin/views/field/SearchApiFieldTrait.php
index e60e09ec..be2d8c6e 100644
--- a/src/Plugin/views/field/SearchApiFieldTrait.php
+++ b/src/Plugin/views/field/SearchApiFieldTrait.php
@@ -12,9 +12,11 @@ use Drupal\Core\TypedData\DataReferenceInterface;
 use Drupal\Core\TypedData\ListInterface;
 use Drupal\Core\TypedData\TranslatableInterface;
 use Drupal\Core\TypedData\TypedDataManagerInterface;
+use Drupal\search_api\LoggerTrait;
 use Drupal\search_api\Plugin\views\SearchApiHandlerTrait;
 use Drupal\search_api\Processor\ConfigurablePropertyInterface;
 use Drupal\search_api\Processor\ProcessorPropertyInterface;
+use Drupal\search_api\SearchApiException;
 use Drupal\search_api\Utility\FieldsHelperInterface;
 use Drupal\search_api\Utility\Utility;
 use Drupal\views\Plugin\views\field\MultiItemsFieldHandlerInterface;
@@ -33,6 +35,7 @@ use Drupal\views\ResultRow;
  */
 trait SearchApiFieldTrait {
 
+  use LoggerTrait;
   use SearchApiHandlerTrait;
 
   /**
@@ -107,15 +110,6 @@ trait SearchApiFieldTrait {
    */
   protected $propertyReplacements = [];
 
-  /**
-   * Cached array of index fields grouped by combined property path.
-   *
-   * @var \Drupal\search_api\Item\FieldInterface[][]|null
-   *
-   * @see \Drupal\search_api\Plugin\views\field\SearchApiFieldTrait::getFieldsForPropertyPath()
-   */
-  protected $fieldsByCombinedPropertyPath;
-
   /**
    * The fields helper.
    *
@@ -343,6 +337,10 @@ trait SearchApiFieldTrait {
     }
     $this->addRetrievedProperty($combined_property_path, $field_id);
     if ($this->options['link_to_item']) {
+      // @todo We don't actually know which object we need, might be from this
+      //   property or any of its parents – depending where the closest entity
+      //   ancestor is. To be 100% accurate, we'd have to somehow already
+      //   determine the correct property here.
       $this->addRetrievedProperty("$combined_property_path:_object");
     }
   }
@@ -455,7 +453,8 @@ trait SearchApiFieldTrait {
   public function preRender(&$values) {
     // We deal with the properties one by one, always loading the necessary
     // values for any nested properties coming afterwards.
-    foreach ($this->expandRequiredProperties() as $properties) {
+    foreach ($this->expandRequiredProperties() as $datasource_id => $properties) {
+      $datasource_id = $datasource_id ?: NULL;
       foreach ($properties as $property_path => $info) {
         $combined_property_path = $info['combined_property_path'];
         $dependents = $info['dependents'];
@@ -465,9 +464,9 @@ trait SearchApiFieldTrait {
           continue;
         }
 
-        $property_values = $this->getValuesToExtract($values, $combined_property_path, $dependents);
+        $property_values = $this->getValuesToExtract($values, $datasource_id, $property_path, $combined_property_path, $dependents);
         $this->extractPropertyValues($values, $combined_property_path, $property_values, $dependents);
-        $this->checkHighlighting($values, $combined_property_path);
+        $this->checkHighlighting($values, $datasource_id, $property_path, $combined_property_path);
       }
     }
   }
@@ -493,11 +492,28 @@ trait SearchApiFieldTrait {
    */
   protected function expandRequiredProperties() {
     $required_properties = [];
-    foreach ($this->retrievedProperties as $datasource_id => $properties) {
+    foreach ($this->retrievedProperties as $datasource_id => $property_paths) {
       if ($datasource_id === '') {
         $datasource_id = NULL;
       }
-      foreach ($properties as $property_path => $combined_property_path) {
+      try {
+        $index_properties = $this->getIndex()->getPropertyDefinitions($datasource_id);
+      }
+      catch (SearchApiException $e) {
+        $this->logException($e);
+        $index_properties = [];
+      }
+      foreach ($property_paths as $property_path => $combined_property_path) {
+        // In case the property is configurable, create a new, unique combined
+        // property path for this field so adding multiple fields based on the
+        // same property works correctly.
+        if (isset($index_properties[$property_path])
+            && $index_properties[$property_path] instanceof ConfigurablePropertyInterface
+            && !empty($this->definition['search_api field'])) {
+          $new_path = $combined_property_path . '|' . $this->definition['search_api field'];
+          $this->propertyReplacements[$combined_property_path] = $new_path;
+          $combined_property_path = $new_path;
+        }
         $paths_to_add = [NULL];
         $path_to_add = '';
         foreach (explode(':', $property_path) as $component) {
@@ -506,8 +522,12 @@ trait SearchApiFieldTrait {
         }
         foreach ($paths_to_add as $path_to_add) {
           if (!isset($required_properties[$datasource_id][$path_to_add])) {
+            $path = $this->createCombinedPropertyPath($datasource_id, $path_to_add);
+            if (isset($this->propertyReplacements[$path])) {
+              $path = $this->propertyReplacements[$path];
+            }
             $required_properties[$datasource_id][$path_to_add] = [
-              'combined_property_path' => $this->createCombinedPropertyPath($datasource_id, $path_to_add),
+              'combined_property_path' => $path,
               'dependents' => [],
             ];
           }
@@ -576,9 +596,13 @@ trait SearchApiFieldTrait {
    *
    * @param \Drupal\views\ResultRow[] $values
    *   The Views result rows from which property values should be extracted.
+   * @param string|null $datasource_id
+   *   The datasource ID of the property to extract (or NULL for datasource-
+   *   independent properties).
+   * @param string $property_path
+   *   The property path of the property to extract.
    * @param string $combined_property_path
-   *   The combined property path of the property to extract. Or NULL to extract
-   *   the result item.
+   *   The combined property path of the property to extract.
    * @param string[] $dependents
    *   The actually required properties (as combined property paths) that
    *   depend on this property.
@@ -587,9 +611,7 @@ trait SearchApiFieldTrait {
    *   The values of the property for each result row, keyed by result row
    *   index.
    */
-  protected function getValuesToExtract(array $values, $combined_property_path, array $dependents) {
-    list ($datasource_id, $property_path) = Utility::splitCombinedId($combined_property_path);
-
+  protected function getValuesToExtract(array $values, $datasource_id, $property_path, $combined_property_path, array $dependents) {
     // Determine the path of the parent property, and the property key to
     // take from it for this property.
     list($parent_path, $name) = Utility::splitPropertyPath($property_path);
@@ -621,9 +643,9 @@ trait SearchApiFieldTrait {
         continue;
       }
 
-      // Then, make sure we even need this property for the current row.
-      // (Will not be the case if all required properties that depend on
-      // this property were already set on the row previously.)
+      // Then, make sure we even need this property for the current row. (Will
+      // not be the case if all required properties that depend on this property
+      // were already set on the row previously.)
       $required = FALSE;
       foreach ($dependents as $dependent) {
         if (!isset($row->$dependent)) {
@@ -661,7 +683,7 @@ trait SearchApiFieldTrait {
         if ($property instanceof ProcessorPropertyInterface) {
           // Determine whether this property is required.
           $is_required = in_array($combined_property_path, $dependents);
-          $this->extractProcessorProperty($property, $row, $combined_property_path, $is_required);
+          $this->extractProcessorProperty($property, $row, $datasource_id, $property_path, $combined_property_path, $is_required);
           continue;
         }
 
@@ -727,21 +749,24 @@ trait SearchApiFieldTrait {
    *   The property definition.
    * @param \Drupal\views\ResultRow $row
    *   The Views result row.
+   * @param string|null $datasource_id
+   *   The datasource ID of the property to extract (or NULL for datasource-
+   *   independent properties).
+   * @param string $property_path
+   *   The property path of the property to extract.
    * @param string $combined_property_path
    *   The combined property path of the property to set.
    * @param bool $is_required
    *   TRUE if the property is directly required, FALSE if it should only be
    *   extracted because some child/ancestor properties are required.
    */
-  protected function extractProcessorProperty(ProcessorPropertyInterface $property, ResultRow $row, $combined_property_path, $is_required) {
+  protected function extractProcessorProperty(ProcessorPropertyInterface $property, ResultRow $row, $datasource_id, $property_path, $combined_property_path, $is_required) {
     $index = $this->getIndex();
     $processor = $index->getProcessor($property->getProcessorId());
     if (!$processor) {
       return;
     }
 
-    list($datasource_id, $property_path) = Utility::splitCombinedId($combined_property_path);
-
     // We need to call the processor's addFieldValues() method in order to get
     // the field value. We do this using a clone of the search item so as to
     // preserve the original state of the item. We also use a dummy field
@@ -754,14 +779,6 @@ trait SearchApiFieldTrait {
           && !empty($property_fields[$this->definition['search_api field']])) {
         $field_id = $this->definition['search_api field'];
         $dummy_field = $property_fields[$field_id];
-        // In case this field is also configurable, create a new, unique
-        // combined property path for this field so adding multiple fields based
-        // on the same property works correctly.
-        if ($property instanceof ConfigurablePropertyInterface) {
-          $new_path = $combined_property_path . '|' . $field_id;
-          $this->propertyReplacements[$combined_property_path] = $new_path;
-          $combined_property_path = $new_path;
-        }
       }
       else {
         $dummy_field = reset($property_fields);
@@ -895,10 +912,15 @@ trait SearchApiFieldTrait {
    * @param \Drupal\views\ResultRow[] $values
    *   The Views result rows for which highlighted field values should be added
    *   where applicable and possible.
+   * @param string|null $datasource_id
+   *   The datasource ID of the property to extract (or NULL for datasource-
+   *   independent properties).
+   * @param string $property_path
+   *   The property path of the property to extract.
    * @param string $combined_property_path
    *   The combined property path of the property for which to add data.
    */
-  protected function checkHighlighting(array $values, $combined_property_path) {
+  protected function checkHighlighting(array $values, $datasource_id, $property_path, $combined_property_path) {
     // If using highlighting data wasn't enabled, we can skip all of this
     // anyways.
     if (empty($this->options['use_highlighting'])) {
@@ -907,15 +929,12 @@ trait SearchApiFieldTrait {
 
     // Since (currently) only fields can be highlighted, not arbitrary
     // properties, we needn't even bother if there are no matching fields.
-    $fields = $this->getFieldsForPropertyPath($combined_property_path);
+    $fields = $this->getFieldsHelper()
+      ->filterForPropertyPath($this->getIndex()->getFields(), $datasource_id, $property_path);
     if (!$fields) {
       return;
     }
 
-    if (!empty($this->propertyReplacements[$combined_property_path])) {
-      $combined_property_path = $this->propertyReplacements[$combined_property_path];
-    }
-
     foreach ($values as $row) {
       // We only want highlighting data if we even wanted (and, thus, extracted)
       // the property's values in the first place.
@@ -938,27 +957,6 @@ trait SearchApiFieldTrait {
     }
   }
 
-  /**
-   * Retrieves all of the index's fields that match the given property path.
-   *
-   * @param string $combined_property_path
-   *   The combined property path to look for.
-   *
-   * @return \Drupal\search_api\Item\FieldInterface[]
-   *   All index fields with the given combined property path, keyed by field
-   *   ID.
-   */
-  protected function getFieldsForPropertyPath($combined_property_path) {
-    if (!isset($this->fieldsByCombinedPropertyPath)) {
-      $this->fieldsByCombinedPropertyPath = [];
-      foreach ($this->getIndex()->getFields() as $field_id => $field) {
-        $this->fieldsByCombinedPropertyPath[$field->getCombinedPropertyPath()][$field_id] = $field;
-      }
-    }
-    $this->fieldsByCombinedPropertyPath += [$combined_property_path => []];
-    return $this->fieldsByCombinedPropertyPath[$combined_property_path];
-  }
-
   /**
    * Combines raw field values with highlighted ones to get a complete set.
    *
diff --git a/src/Plugin/views/field/SearchApiRenderedItem.php b/src/Plugin/views/field/SearchApiRenderedItem.php
index 15c67428..ce2be0bb 100644
--- a/src/Plugin/views/field/SearchApiRenderedItem.php
+++ b/src/Plugin/views/field/SearchApiRenderedItem.php
@@ -4,7 +4,6 @@ namespace Drupal\search_api\Plugin\views\field;
 
 use Drupal\Core\Form\FormStateInterface;
 use Drupal\Core\TypedData\ComplexDataInterface;
-use Drupal\search_api\LoggerTrait;
 use Drupal\search_api\Plugin\views\query\SearchApiQuery;
 use Drupal\search_api\SearchApiException;
 use Drupal\views\Plugin\views\display\DisplayPluginBase;
@@ -22,7 +21,6 @@ use Symfony\Component\DependencyInjection\ContainerInterface;
  */
 class SearchApiRenderedItem extends FieldPluginBase {
 
-  use LoggerTrait;
   use SearchApiFieldTrait;
 
   /**
diff --git a/src/Plugin/views/filter/SearchApiFulltext.php b/src/Plugin/views/filter/SearchApiFulltext.php
index f3c4829f..bd9f6c53 100644
--- a/src/Plugin/views/filter/SearchApiFulltext.php
+++ b/src/Plugin/views/filter/SearchApiFulltext.php
@@ -301,9 +301,6 @@ class SearchApiFulltext extends FilterPluginBase {
     $fields = $this->options['fields'];
     $fields = $fields ? $fields : array_keys($this->getFulltextFields());
     $query = $this->getQuery();
-    if ($query->shouldAbort()) {
-      return;
-    }
 
     // Save any keywords that were already set.
     $old = $query->getKeys();
diff --git a/src/Plugin/views/query/SearchApiQuery.php b/src/Plugin/views/query/SearchApiQuery.php
index f77a15aa..3d8b35ad 100644
--- a/src/Plugin/views/query/SearchApiQuery.php
+++ b/src/Plugin/views/query/SearchApiQuery.php
@@ -3,6 +3,8 @@
 namespace Drupal\search_api\Plugin\views\query;
 
 use Drupal\Component\Render\FormattableMarkup;
+use Drupal\Core\Cache\Cache;
+use Drupal\Core\Cache\CacheableDependencyInterface;
 use Drupal\Core\Database\Query\ConditionInterface;
 use Drupal\Core\Entity\EntityInterface;
 use Drupal\Core\Entity\EntityTypeManagerInterface;
@@ -16,6 +18,7 @@ use Drupal\search_api\ParseMode\ParseModeInterface;
 use Drupal\search_api\Plugin\views\field\SearchApiStandard;
 use Drupal\search_api\Plugin\views\ResultRow;
 use Drupal\search_api\Processor\ConfigurablePropertyInterface;
+use Drupal\search_api\Query\ConditionGroup;
 use Drupal\search_api\Query\ConditionGroupInterface;
 use Drupal\search_api\Query\QueryInterface;
 use Drupal\search_api\Query\ResultSetInterface;
@@ -258,7 +261,7 @@ class SearchApiQuery extends QueryPluginBase {
       if ($display_type === 'rest_export') {
         $display_type = 'rest';
       }
-      $this->query->setSearchId("views_$display_type:" . $view->id() . '__' . $view->current_display);
+      $this->query->setSearchId("views_$display_type:" . $view->id() . '__' . $display->display['id']);
       $this->query->setOption('search_api_view', $view);
     }
     catch (\Exception $e) {
@@ -687,6 +690,49 @@ class SearchApiQuery extends QueryPluginBase {
     }
   }
 
+  /**
+   * {@inheritdoc}
+   */
+  public function getCacheContexts() {
+    $query = $this->getSearchApiQuery();
+    if ($query instanceof CacheableDependencyInterface) {
+      return $query->getCacheContexts();
+    }
+
+    // We are not returning the cache contexts from the parent class since these
+    // are based on the default SQL storage from Views, while our results are
+    // coming from the search engine.
+    return [];
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getCacheTags() {
+    $tags = parent::getCacheTags();
+
+    $query = $this->getSearchApiQuery();
+    if ($query instanceof CacheableDependencyInterface) {
+      $tags = Cache::mergeTags($query->getCacheTags(), $tags);
+    }
+
+    return $tags;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getCacheMaxAge() {
+    $max_age = parent::getCacheMaxAge();
+
+    $query = $this->getSearchApiQuery();
+    if ($query instanceof CacheableDependencyInterface) {
+      $max_age = Cache::mergeMaxAges($query->getCacheMaxAge(), $max_age);
+    }
+
+    return $max_age;
+  }
+
   /**
    * Retrieves the conditions placed on this query.
    *
@@ -861,7 +907,7 @@ class SearchApiQuery extends QueryPluginBase {
     if (!$this->shouldAbort()) {
       return $this->query->createConditionGroup($conjunction, $tags);
     }
-    return NULL;
+    return new ConditionGroup($conjunction, $tags);
   }
 
   /**
diff --git a/src/Processor/EntityProcessorProperty.php b/src/Processor/EntityProcessorProperty.php
index e670f33b..4f3db769 100644
--- a/src/Processor/EntityProcessorProperty.php
+++ b/src/Processor/EntityProcessorProperty.php
@@ -23,4 +23,11 @@ class EntityProcessorProperty extends EntityDataDefinition implements ProcessorP
     return !empty($this->definition['hidden']);
   }
 
+  /**
+   * {@inheritdoc}
+   */
+  public function isList() {
+    return !empty($this->definition['is_list']) || parent::isList();
+  }
+
 }
diff --git a/src/Query/Query.php b/src/Query/Query.php
index e415cc2c..d9aaa059 100644
--- a/src/Query/Query.php
+++ b/src/Query/Query.php
@@ -2,6 +2,9 @@
 
 namespace Drupal\search_api\Query;
 
+use Drupal\Core\Cache\Cache;
+use Drupal\Core\Cache\RefinableCacheableDependencyInterface;
+use Drupal\Core\Cache\RefinableCacheableDependencyTrait;
 use Drupal\Core\DependencyInjection\DependencySerializationTrait;
 use Drupal\Core\Extension\ModuleHandlerInterface;
 use Drupal\Core\StringTranslation\StringTranslationTrait;
@@ -15,9 +18,10 @@ use Drupal\search_api\Utility\QueryHelperInterface;
 /**
  * Provides a standard implementation for a Search API query.
  */
-class Query implements QueryInterface {
+class Query implements QueryInterface, RefinableCacheableDependencyInterface {
 
   use StringTranslationTrait;
+  use RefinableCacheableDependencyTrait;
   use DependencySerializationTrait {
     __sleep as traitSleep;
     __wakeup as traitWakeup;
@@ -696,6 +700,40 @@ class Query implements QueryInterface {
     return $this->originalQuery ?: clone $this;
   }
 
+  /**
+   * {@inheritdoc}
+   */
+  public function getCacheContexts() {
+    $contexts = $this->cacheContexts;
+
+    foreach ($this->getIndex()->getDatasources() as $datasource) {
+      $contexts = Cache::mergeContexts($datasource->getListCacheContexts(), $contexts);
+    }
+
+    return $contexts;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getCacheTags() {
+    $tags = $this->cacheTags;
+
+    // If the configuration of the search index changes we should invalidate the
+    // views that show results from this index.
+    $index_tags = $this->getIndex()->getCacheTagsToInvalidate();
+    $tags = Cache::mergeTags($index_tags, $tags);
+
+    return $tags;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getCacheMaxAge() {
+    return $this->cacheMaxAge;
+  }
+
   /**
    * {@inheritdoc}
    */
diff --git a/tests/search_api_test/search_api_test.info.yml b/tests/search_api_test/search_api_test.info.yml
index 7bf224dc..fa1580ac 100644
--- a/tests/search_api_test/search_api_test.info.yml
+++ b/tests/search_api_test/search_api_test.info.yml
@@ -1,7 +1,7 @@
 name: 'Search API Test'
 type: module
 description: 'Support module for Search API tests'
-package: Search
+package: Testing
 dependencies:
   - search_api:search_api
 core: 8.x
diff --git a/tests/search_api_test/search_api_test.module b/tests/search_api_test/search_api_test.module
index deeb41a7..eb14868a 100644
--- a/tests/search_api_test/search_api_test.module
+++ b/tests/search_api_test/search_api_test.module
@@ -14,7 +14,7 @@ use Drupal\node\NodeInterface;
 function search_api_test_node_grants(AccountInterface $account, $op) {
   $grants = [];
 
-  if (\Drupal::state()->get('search_api_test_add_node_access_grant', TRUE)) {
+  if (\Drupal::state()->get('search_api_test_add_node_access_grant', FALSE)) {
     $grants['search_api_test'] = [$account->id()];
   }
 
@@ -27,7 +27,7 @@ function search_api_test_node_grants(AccountInterface $account, $op) {
 function search_api_test_node_access_records(NodeInterface $node) {
   $grants = [];
 
-  if (\Drupal::state()->get('search_api_test_add_node_access_grant', TRUE)) {
+  if (\Drupal::state()->get('search_api_test_add_node_access_grant', FALSE)) {
     $grants[] = [
       'realm' => 'search_api_test',
       'gid' => $node->getOwnerId(),
diff --git a/tests/search_api_test_db/search_api_test_db.info.yml b/tests/search_api_test_db/search_api_test_db.info.yml
index 91c8d5e0..a02a1548 100644
--- a/tests/search_api_test_db/search_api_test_db.info.yml
+++ b/tests/search_api_test_db/search_api_test_db.info.yml
@@ -1,7 +1,7 @@
 type: module
 name: 'Database search test'
 description: 'Provides a setup for testing Database Search.'
-package: 'Search API'
+package: Testing
 dependencies:
   - search_api:search_api_db
   - search_api:search_api_test_example_content
diff --git a/tests/search_api_test_example_content/search_api_test_example_content.info.yml b/tests/search_api_test_example_content/search_api_test_example_content.info.yml
index 87d5bf67..a2134767 100644
--- a/tests/search_api_test_example_content/search_api_test_example_content.info.yml
+++ b/tests/search_api_test_example_content/search_api_test_example_content.info.yml
@@ -1,7 +1,7 @@
 type: module
 name: 'Example Content'
 description: 'Provides field definitions for example content.'
-package: 'Search API'
+package: Testing
 dependencies:
   - drupal:entity_test
 core: 8.x
diff --git a/tests/search_api_test_extraction/search_api_test_extraction.info.yml b/tests/search_api_test_extraction/search_api_test_extraction.info.yml
index 6b097477..11a7cfad 100644
--- a/tests/search_api_test_extraction/search_api_test_extraction.info.yml
+++ b/tests/search_api_test_extraction/search_api_test_extraction.info.yml
@@ -1,7 +1,7 @@
 type: module
 name: 'Field values extraction search test'
 description: 'Provides a setup for testing field values extraction.'
-package: 'Search API'
+package: Testing
 dependencies:
   - drupal:entity_test
 core: 8.x
diff --git a/tests/search_api_test_inconsistent_config/search_api_test_inconsistent_config.info.yml b/tests/search_api_test_inconsistent_config/search_api_test_inconsistent_config.info.yml
index 63f29235..70ab9767 100644
--- a/tests/search_api_test_inconsistent_config/search_api_test_inconsistent_config.info.yml
+++ b/tests/search_api_test_inconsistent_config/search_api_test_inconsistent_config.info.yml
@@ -1,7 +1,7 @@
 name: 'Search API Inconsistent Configs Test'
 type: module
 description: 'Support module for Search API tests'
-package: Search
+package: Testing
 dependencies:
   - search_api:search_api
   - search_api:search_api_test
diff --git a/tests/search_api_test_no_ui/search_api_test_no_ui.info.yml b/tests/search_api_test_no_ui/search_api_test_no_ui.info.yml
index 32fcb1c3..ffce8020 100644
--- a/tests/search_api_test_no_ui/search_api_test_no_ui.info.yml
+++ b/tests/search_api_test_no_ui/search_api_test_no_ui.info.yml
@@ -1,7 +1,7 @@
 name: 'Search API Test No UI'
 type: module
 description: 'Support module for Search API tests ("No UI" plugins)'
-package: Search
+package: Testing
 dependencies:
   - search_api:search_api
 core: 8.x
diff --git a/tests/search_api_test_node_indexing/config/install/search_api.index.test_node_index.yml b/tests/search_api_test_node_indexing/config/install/search_api.index.test_node_index.yml
new file mode 100644
index 00000000..b2af7e1d
--- /dev/null
+++ b/tests/search_api_test_node_indexing/config/install/search_api.index.test_node_index.yml
@@ -0,0 +1,48 @@
+id: test_node_index
+name: 'Test node index'
+description: 'An index of node entities used for testing'
+read_only: false
+field_settings:
+  status:
+    label: Published
+    datasource_id: 'entity:node'
+    property_path: status
+    type: boolean
+    dependencies:
+      module:
+        - node
+  title:
+    label: Title
+    datasource_id: 'entity:node'
+    property_path: title
+    type: string
+    dependencies:
+      module:
+        - node
+processor_settings:
+  add_url: {  }
+  aggregated_field: {  }
+  rendered_item: {  }
+options:
+  cron_limit: -1
+  index_directly: false
+datasource_settings:
+  'entity:node':
+    bundles:
+      default: true
+      selected: {  }
+    languages:
+      default: true
+      selected: {  }
+tracker_settings:
+  default:
+    indexing_order: fifo
+server: database_search_server
+status: true
+langcode: en
+dependencies:
+  config:
+    - search_api.server.database_search_server
+  module:
+    - node
+    - search_api
diff --git a/tests/search_api_test_node_indexing/config/install/search_api.server.database_search_server.yml b/tests/search_api_test_node_indexing/config/install/search_api.server.database_search_server.yml
new file mode 100644
index 00000000..0e79fda4
--- /dev/null
+++ b/tests/search_api_test_node_indexing/config/install/search_api.server.database_search_server.yml
@@ -0,0 +1,13 @@
+id: database_search_server
+name: 'Database search server'
+description: 'A server used for testing'
+backend: search_api_db
+backend_config:
+  database: 'default:default'
+  min_chars: 3
+  matching: words
+status: true
+langcode: en
+dependencies:
+  module:
+    - search_api_db
diff --git a/tests/search_api_test_node_indexing/config/install/views.view.search_api_test_node_view.yml b/tests/search_api_test_node_indexing/config/install/views.view.search_api_test_node_view.yml
new file mode 100644
index 00000000..0ee6bce9
--- /dev/null
+++ b/tests/search_api_test_node_indexing/config/install/views.view.search_api_test_node_view.yml
@@ -0,0 +1,107 @@
+langcode: en
+status: true
+dependencies:
+  config:
+    - search_api.index.test_node_index
+  module:
+    - search_api
+id: search_api_test_node_view
+label: 'Search API test node view'
+module: views
+description: ''
+tag: ''
+base_table: search_api_index_test_node_index
+base_field: search_api_id
+core: 8.x
+display:
+  default:
+    display_plugin: default
+    id: default
+    display_title: Master
+    position: 0
+    display_options:
+      access:
+        type: none
+        options: {  }
+      cache:
+        type: search_api_tag
+        options: {  }
+      query:
+        type: search_api_query
+        options:
+          bypass_access: false
+          skip_access: false
+          preserve_facet_query_args: false
+      exposed_form:
+        type: basic
+        options:
+          submit_button: Search
+          reset_button: false
+          reset_button_label: Reset
+          exposed_sorts_label: 'Sort by'
+          expose_sort_order: true
+          sort_asc_label: Asc
+          sort_desc_label: Desc
+      pager:
+        type: full
+        options:
+          items_per_page: 10
+          offset: 0
+          id: 0
+          total_pages: null
+          expose:
+            items_per_page: false
+            items_per_page_label: 'Items per page'
+            items_per_page_options: '5, 10, 20, 40, 60'
+            items_per_page_options_all: false
+            items_per_page_options_all_label: '- All -'
+            offset: false
+            offset_label: Offset
+          tags:
+            previous: ‹‹
+            next: ››
+      style:
+        type: default
+      row:
+        type: fields
+      fields:
+        title:
+          id: title
+          table: search_api_index_test_node_index
+          field: title
+          plugin_id: search_api_field
+      filters: {  }
+      sorts: {  }
+      title: 'Search API test node view'
+      header: {  }
+      footer: {  }
+      empty: {  }
+      relationships: {  }
+      arguments: {  }
+      display_extenders: {  }
+    cache_metadata:
+      max-age: -1
+      contexts:
+        - 'languages:language_content'
+        - 'languages:language_interface'
+        - url.query_args
+        - 'user.node_grants:view'
+      tags:
+        - 'config:search_api.index.test_node_index'
+  page_1:
+    display_plugin: page
+    id: page_1
+    display_title: Page
+    position: 1
+    display_options:
+      display_extenders: {  }
+      path: search-api-test-node-view
+    cache_metadata:
+      max-age: -1
+      contexts:
+        - 'languages:language_content'
+        - 'languages:language_interface'
+        - url.query_args
+        - 'user.node_grants:view'
+      tags:
+        - 'config:search_api.index.test_node_index'
diff --git a/tests/search_api_test_node_indexing/search_api_test_node_indexing.info.yml b/tests/search_api_test_node_indexing/search_api_test_node_indexing.info.yml
new file mode 100644
index 00000000..10cdc56f
--- /dev/null
+++ b/tests/search_api_test_node_indexing/search_api_test_node_indexing.info.yml
@@ -0,0 +1,8 @@
+type: module
+name: 'Search API node indexing test'
+description: 'Test module for testing indexing of nodes in Search API.'
+package: 'Search API'
+dependencies:
+  - search_api:search_api_db
+core: 8.x
+hidden: true
diff --git a/tests/search_api_test_views/search_api_test_views.info.yml b/tests/search_api_test_views/search_api_test_views.info.yml
index 23407302..49e133b6 100644
--- a/tests/search_api_test_views/search_api_test_views.info.yml
+++ b/tests/search_api_test_views/search_api_test_views.info.yml
@@ -1,7 +1,7 @@
 name: 'Search API Views Test'
 type: module
 description: 'Support module for Search API Views tests'
-package: Search
+package: Testing
 dependencies:
   - search_api:search_api
   - search_api:search_api_test_db
diff --git a/tests/search_api_test_views/search_api_test_views.module b/tests/search_api_test_views/search_api_test_views.module
index 739ef892..e6761951 100644
--- a/tests/search_api_test_views/search_api_test_views.module
+++ b/tests/search_api_test_views/search_api_test_views.module
@@ -5,6 +5,7 @@
  * Contains hook implementations for the Search API Views Test module.
  */
 
+use Drupal\Core\Cache\RefinableCacheableDependencyInterface;
 use Drupal\Core\Entity\EntityInterface;
 use Drupal\Core\Entity\EntityListBuilder;
 use Drupal\search_api\Query\QueryInterface;
@@ -12,14 +13,25 @@ use Drupal\search_api\Query\QueryInterface;
 /**
  * Implements hook_search_api_query_alter().
  *
- * Prints the contents of the "search_api_retrieved_field_values" query option
- * to the page (if present) so it can be checked by the testing code.
+ * - Prints the contents of the "search_api_retrieved_field_values" query option
+ *   to the page (if present) so it can be checked by the testing code.
+ * - Alters the query to include custom cacheability metadata, so that we can
+ *   test if modules can alter the cacheability of search queries.
  */
 function search_api_test_views_search_api_query_alter(QueryInterface $query) {
   $fields = $query->getOption('search_api_retrieved_field_values');
   if ($fields) {
     \Drupal::messenger()->addStatus("'" . implode("' '", $fields) . "'");
   }
+
+  if (\Drupal::state()->get('search_api_test_views.alter_query_cacheability_metadata', FALSE)) {
+    if ($query instanceof RefinableCacheableDependencyInterface) {
+      // Alter in some imaginary cacheability metadata for testing.
+      $query->addCacheContexts(['search_api_test_context']);
+      $query->addCacheTags(['search_api:test_tag']);
+      $query->mergeCacheMaxAge(100);
+    }
+  }
 }
 
 /**
diff --git a/tests/src/Functional/IntegrationTest.php b/tests/src/Functional/IntegrationTest.php
index 105aec10..344d6035 100644
--- a/tests/src/Functional/IntegrationTest.php
+++ b/tests/src/Functional/IntegrationTest.php
@@ -312,7 +312,7 @@ class IntegrationTest extends SearchApiBrowserTestBase {
     $this->submitForm($edit, 'Save');
     $this->assertSession()->pageTextContains('Index name field is required.');
     $this->assertSession()->pageTextContains('Machine-readable name field is required.');
-    $this->assertSession()->pageTextContains('Data sources field is required.');
+    $this->assertSession()->pageTextContains('Datasources field is required.');
 
     $edit = [
       'name' => $index_name,
@@ -477,7 +477,7 @@ class IntegrationTest extends SearchApiBrowserTestBase {
   }
 
   /**
-   * Tests that an entity without bundles can be used as a data source.
+   * Tests that an entity without bundles can be used as a datasource.
    */
   protected function checkUserIndexCreation() {
     $edit = [
diff --git a/tests/src/FunctionalJavascript/AjaxTest.php b/tests/src/FunctionalJavascript/AjaxTest.php
index 92908076..b0d96b7f 100644
--- a/tests/src/FunctionalJavascript/AjaxTest.php
+++ b/tests/src/FunctionalJavascript/AjaxTest.php
@@ -2,7 +2,7 @@
 
 namespace Drupal\Tests\search_api\FunctionalJavascript;
 
-use Drupal\FunctionalJavascriptTests\JavascriptTestBase;
+use Drupal\FunctionalJavascriptTests\WebDriverTestBase;
 use Drupal\node\Entity\NodeType;
 use Drupal\search_api\Utility\Utility;
 use Drupal\search_api_test\PluginTestTrait;
@@ -12,7 +12,7 @@ use Drupal\search_api_test\PluginTestTrait;
  *
  * @group search_api
  */
-class AjaxTest extends JavascriptTestBase {
+class AjaxTest extends WebDriverTestBase {
 
   use PluginTestTrait;
 
diff --git a/tests/src/Kernel/Processor/ContentAccessTest.php b/tests/src/Kernel/Processor/ContentAccessTest.php
index 0d287112..82d91fe5 100644
--- a/tests/src/Kernel/Processor/ContentAccessTest.php
+++ b/tests/src/Kernel/Processor/ContentAccessTest.php
@@ -48,6 +48,9 @@ class ContentAccessTest extends ProcessorTestBase {
   public function setUp($processor = NULL) {
     parent::setUp('content_access');
 
+    // Activate our custom grant.
+    \Drupal::state()->set('search_api_test_add_node_access_grant', TRUE);
+
     // Create a node type for testing.
     $type = NodeType::create(['type' => 'page', 'name' => 'page']);
     $type->save();
@@ -362,7 +365,7 @@ class ContentAccessTest extends ProcessorTestBase {
 
     // Verify that there are no properties if a datasource is given.
     $properties = $this->processor->getPropertyDefinitions($this->index->getDatasource('entity:node'));
-    $this->assertEquals([], $properties, '"search_api_node_grants" property not added when data source is given.');
+    $this->assertEquals([], $properties, '"search_api_node_grants" property not added when datasource is given.');
   }
 
   /**
diff --git a/tests/src/Kernel/Processor/RenderedItemTest.php b/tests/src/Kernel/Processor/RenderedItemTest.php
index 28a19c6a..c48d2715 100644
--- a/tests/src/Kernel/Processor/RenderedItemTest.php
+++ b/tests/src/Kernel/Processor/RenderedItemTest.php
@@ -367,7 +367,7 @@ class RenderedItemTest extends ProcessorTestBase {
 
     // Verify that there are no properties if a datasource is given.
     $properties = $this->processor->getPropertyDefinitions($this->index->getDatasource('entity:node'));
-    $this->assertEquals([], $properties, '"render_item" property not added when data source is given.');
+    $this->assertEquals([], $properties, '"render_item" property not added when datasource is given.');
   }
 
   /**
diff --git a/tests/src/Kernel/Processor/ReverseEntityReferencesTest.php b/tests/src/Kernel/Processor/ReverseEntityReferencesTest.php
index 1fba7acb..333548b6 100644
--- a/tests/src/Kernel/Processor/ReverseEntityReferencesTest.php
+++ b/tests/src/Kernel/Processor/ReverseEntityReferencesTest.php
@@ -129,6 +129,7 @@ class ReverseEntityReferencesTest extends ProcessorTestBase {
     $this->assertInstanceOf(ProcessorPropertyInterface::class, $property);
     $this->assertEquals('node', $property->getEntityTypeId());
     $this->assertEquals('reverse_entity_references', $property->getProcessorId());
+    $this->assertTrue($property->isList());
   }
 
   /**
diff --git a/tests/src/Kernel/Views/ViewsCacheInvalidationTest.php b/tests/src/Kernel/Views/ViewsCacheInvalidationTest.php
new file mode 100644
index 00000000..e526c623
--- /dev/null
+++ b/tests/src/Kernel/Views/ViewsCacheInvalidationTest.php
@@ -0,0 +1,473 @@
+<?php
+
+namespace Drupal\Tests\search_api\Kernel\Views;
+
+use Drupal\Core\Cache\Cache;
+use Drupal\KernelTests\KernelTestBase;
+use Drupal\node\Entity\Node;
+use Drupal\node\Entity\NodeType;
+use Drupal\search_api\Entity\Index;
+use Drupal\Tests\search_api\Kernel\PostRequestIndexingTrait;
+use Drupal\Tests\user\Traits\UserCreationTrait;
+use Drupal\views\Tests\AssertViewsCacheTagsTrait;
+
+/**
+ * Tests that cached Search API views get invalidated at the right occasions.
+ *
+ * @group search_api
+ */
+class ViewsCacheInvalidationTest extends KernelTestBase {
+
+  use AssertViewsCacheTagsTrait;
+  use PostRequestIndexingTrait;
+  use UserCreationTrait;
+
+  /**
+   * The ID of the view used in the test.
+   */
+  const TEST_VIEW_ID = 'search_api_test_node_view';
+
+  /**
+   * The display ID used in the test.
+   */
+  const TEST_VIEW_DISPLAY_ID = 'page_1';
+
+  /**
+   * The entity type manager.
+   *
+   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   */
+  protected $entityTypeManager;
+
+  /**
+   * The service that is responsible for creating Views executable objects.
+   *
+   * @var \Drupal\views\ViewExecutableFactory
+   */
+  protected $viewExecutableFactory;
+
+  /**
+   * The renderer.
+   *
+   * @var \Drupal\Core\Render\RendererInterface
+   */
+  protected $renderer;
+
+  /**
+   * The cache tags invalidator.
+   *
+   * @var \Drupal\Core\Cache\CacheTagsInvalidator
+   */
+  protected $cacheTagsInvalidator;
+
+  /**
+   * The current user service.
+   *
+   * @var \Drupal\Core\Session\AccountProxyInterface
+   */
+  protected $currentUser;
+
+  /**
+   * The search index used for testing.
+   *
+   * @var \Drupal\search_api\IndexInterface
+   */
+  protected $index;
+
+  /**
+   * Test users.
+   *
+   * @var \Drupal\user\UserInterface[]
+   */
+  protected $users;
+
+  /**
+   * A test content type.
+   *
+   * @var \Drupal\node\NodeTypeInterface
+   */
+  protected $contentType;
+
+  /**
+   * Test nodes.
+   *
+   * @var \Drupal\node\NodeInterface[]
+   */
+  protected $nodes;
+
+  /**
+   * {@inheritdoc}
+   */
+  protected static $modules = [
+    'field',
+    'node',
+    'rest',
+    'search_api',
+    'search_api_db',
+    'search_api_test',
+    'search_api_test_node_indexing',
+    'search_api_test_views',
+    'serialization',
+    'system',
+    'text',
+    'user',
+    'views',
+  ];
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function setUp() {
+    parent::setUp();
+
+    $this->installSchema('node', ['node_access']);
+    $this->installSchema('search_api', ['search_api_item']);
+    $this->installSchema('system', ['sequences']);
+
+    $this->installEntitySchema('node');
+    $this->installEntitySchema('search_api_task');
+    $this->installEntitySchema('user');
+
+    $this->installConfig([
+      'node',
+      'search_api',
+      'search_api_test_node_indexing',
+      'search_api_test_views',
+    ]);
+
+    $this->entityTypeManager = $this->container->get('entity_type.manager');
+    $this->viewExecutableFactory = $this->container->get('views.executable');
+    $this->renderer = $this->container->get('renderer');
+    $this->cacheTagsInvalidator = $this->container->get('cache_tags.invalidator');
+    $this->currentUser = $this->container->get('current_user');
+
+    // Use the test search index from the search_api_test_db module.
+    $this->index = Index::load('test_node_index');
+
+    // Create a test content type.
+    $this->contentType = NodeType::create([
+      'name' => 'Page',
+      'type' => 'page',
+    ]);
+    $this->contentType->save();
+
+    // Create some test content and index it.
+    foreach (['Cheery' => TRUE, 'Carrot' => TRUE, 'Detritus' => FALSE] as $title => $status) {
+      $this->createNode($title, $status);
+    }
+    $this->index->indexItems();
+
+    // Create a dummy test user. This user will get UID 1 which is handled as
+    // the root user and can bypass all access restrictions. This is not used
+    // in the test.
+    $this->createUser();
+
+    // Create two test users, one with permission to view unpublished entities,
+    // and one without.
+    $this->users['no-access'] = $this->createUser(['access content']);
+    $this->users['has-access'] = $this->createUser(['access content', 'bypass node access']);
+  }
+
+  /**
+   * Tests that a cached views query result is invalidated at the right moments.
+   */
+  public function testQueryCacheInvalidation() {
+    // We are testing two variants of the view, one for users that have
+    // permission to view unpublished entities, and one for users that do not.
+    // Initially both variants should be uncached.
+    $this->assertNotCached('no-access');
+    $this->assertNotCached('has-access');
+
+    // Check that the user with the 'bypass node access' permission can see all
+    // 3 items.
+    $this->assertViewsResult('has-access', ['Cheery', 'Carrot', 'Detritus']);
+
+    // The result should now be cached for the privileged user.
+    $this->assertNotCached('no-access');
+    $this->assertCached('has-access');
+
+    // Check that the user without the 'bypass node access' permission can only
+    // see the published items.
+    $this->assertViewsResult('no-access', ['Cheery', 'Carrot']);
+
+    // Both results should now be cached.
+    $this->assertCached('no-access');
+    $this->assertCached('has-access');
+
+    // Add another unpublished item.
+    $this->createNode('Angua', FALSE);
+
+    // Our search index is not configured to automatically index items, so just
+    // creating a node should not invalidate the caches.
+    $this->assertCached('no-access');
+    $this->assertCached('has-access');
+
+    // Index the item, this should invalidate the caches.
+    $this->index->indexItems();
+    $this->assertNotCached('no-access');
+    $this->assertNotCached('has-access');
+
+    // Check that the user without the 'bypass node access' permission can still
+    // only see the published items.
+    $this->assertViewsResult('no-access', ['Cheery', 'Carrot']);
+    $this->assertCached('no-access');
+    $this->assertNotCached('has-access');
+
+    // Check that the user with the 'bypass node access' permission can see all
+    // 4 items.
+    $this->assertViewsResult('has-access', ['Angua', 'Cheery', 'Carrot', 'Detritus']);
+    $this->assertCached('no-access');
+    $this->assertCached('has-access');
+
+    // Grant the permission to 'bypass node access' to the unprivileged user.
+    $privileged_role = $this->users['has-access']->getRoles()[1];
+    $this->users['no-access']->addRole($privileged_role);
+    $this->users['no-access']->save();
+
+    // Changing the roles of a user should not affect the cached results. The
+    // user will now have a new cache context, but the old context should still
+    // be present for all other users that still have the same combination of
+    // roles that our 'no-access' user had before they were changed.
+    // In fact, since our user now has the same set of roles as the 'has-access'
+    // user, the user will immediately benefit from the cached results that
+    // already exist for the cache contexts of the 'has-access' user.
+    $this->assertCached('no-access');
+    $this->assertCached('has-access');
+
+    // The user should now be able to see all 4 items.
+    $this->assertViewsResult('no-access', ['Angua', 'Cheery', 'Carrot', 'Detritus']);
+    $this->assertCached('no-access');
+    $this->assertCached('has-access');
+
+    // Remove the role again from the unprivileged user. This also should not
+    // affect cached results. The 'no-access' user now switches back to only
+    // being able to see the published items, and everything is still happily
+    // cached.
+    $this->users['no-access']->removeRole($privileged_role);
+    $this->users['no-access']->save();
+    $this->assertCached('no-access');
+    $this->assertCached('has-access');
+    $this->assertViewsResult('no-access', ['Cheery', 'Carrot']);
+    $this->assertCached('no-access');
+    $this->assertCached('has-access');
+
+    // Edit one of the test content entities. This should not affect the cached
+    // view until the search index is updated.
+    $this->nodes['Cheery']->set('title', 'Cheery Littlebottom')->save();
+    $this->assertCached('no-access');
+    $this->assertCached('has-access');
+    $this->index->indexItems();
+    $this->assertNotCached('no-access');
+    $this->assertNotCached('has-access');
+
+    // The view should show the updated title when displayed, and the result
+    // should be cached.
+    $this->assertViewsResult('has-access', ['Angua', 'Cheery', 'Carrot', 'Detritus']);
+    $this->assertNotCached('no-access');
+    $this->assertCached('has-access');
+    $this->assertViewsResult('no-access', ['Cheery', 'Carrot']);
+    $this->assertCached('no-access');
+    $this->assertCached('has-access');
+
+    // Delete one of the test content entities. This takes effect immediately,
+    // there is no need to wait until the search index is updated.
+    // @see search_api_entity_delete()
+    $this->nodes['Carrot']->delete();
+    $this->assertNotCached('no-access');
+    $this->assertNotCached('has-access');
+
+    // The view should no longer include the deleted content now, and the result
+    // should be cached after the view has been displayed.
+    $this->assertViewsResult('no-access', ['Cheery']);
+    $this->assertCached('no-access');
+    $this->assertNotCached('has-access');
+    $this->assertViewsResult('has-access', ['Angua', 'Cheery', 'Detritus']);
+    $this->assertCached('no-access');
+    $this->assertCached('has-access');
+
+    // Update the search index configuration so it will index items immediately
+    // when they are created or updated.
+    $this->index->setOption('index_directly', TRUE)->save();
+
+    // Changing the configuration of the index should invalidate all views that
+    // show its data.
+    $this->assertNotCached('no-access');
+    $this->assertNotCached('has-access');
+
+    // Check that the expected results are still returned and are cacheable.
+    $this->assertViewsResult('no-access', ['Cheery']);
+    $this->assertViewsResult('has-access', ['Angua', 'Cheery', 'Detritus']);
+    $this->assertCached('no-access');
+    $this->assertCached('has-access');
+
+    // Change the configuration of the view. This should also invalidate all
+    // displays of the view.
+    $view = $this->getView();
+    $view->setItemsPerPage(20);
+    $view->save();
+    $this->assertNotCached('no-access');
+    $this->assertNotCached('has-access');
+
+    // Check that the expected results are still returned and are cacheable.
+    $this->assertViewsResult('no-access', ['Cheery']);
+    $this->assertViewsResult('has-access', ['Angua', 'Cheery', 'Detritus']);
+    $this->assertCached('no-access');
+    $this->assertCached('has-access');
+
+    // Edit one of the test content entities. Because the search index is being
+    // updated immediately, the cached views should be cleared without having to
+    // perform a manual indexing step.
+    $this->nodes['Angua']->set('title', 'Angua von Überwald')->save();
+    $this->assertNotCached('no-access');
+    $this->assertNotCached('has-access');
+
+    // Check that the updated results are shown and are cacheable.
+    $this->assertViewsResult('no-access', ['Cheery']);
+    $this->assertViewsResult('has-access', ['Angua', 'Cheery', 'Detritus']);
+    $this->assertCached('no-access');
+    $this->assertCached('has-access');
+  }
+
+  /**
+   * Checks that the view is cached for the given user.
+   *
+   * @param string $user_key
+   *   The key of the user for which to perform the check.
+   */
+  protected function assertCached($user_key) {
+    $this->doAssertCached('assertNotEmpty', $user_key);
+  }
+
+  /**
+   * Checks that the view is not cached for the given user.
+   *
+   * @param string $user_key
+   *   The key of the user for which to perform the check.
+   */
+  protected function assertNotCached($user_key) {
+    $this->doAssertCached('assertEmpty', $user_key);
+  }
+
+  /**
+   * Checks the cache status of the view for the given user.
+   *
+   * @param string $assert_method
+   *   The method to use for asserting that the view is cached or not cached.
+   * @param int $user_key
+   *   The key of the user for which to perform the check.
+   */
+  protected function doAssertCached($assert_method, $user_key) {
+    // Ensure that any post request indexing is done. This is normally handled
+    // at the end of the request but since we are running a KernelTest we are
+    // not executing any requests and need to trigger this manually.
+    $this->triggerPostRequestIndexing();
+
+    // Set the user that will be used to check the cache status.
+    $this->setCurrentUser($user_key);
+
+    // Retrieve the cached data and perform the assertion.
+    $view = $this->getView();
+    $view->build();
+    /** @var \Drupal\views\Plugin\views\cache\CachePluginBase $cache */
+    $cache = $view->getDisplay()->getPlugin('cache');
+    $cached_data = $cache->cacheGet('results');
+
+    $this->$assert_method($cached_data);
+  }
+
+  /**
+   * Checks that the view for the given user contains the expected results.
+   *
+   * @param string $user_key
+   *   The key of the user to check.
+   * @param array $node_keys
+   *   The keys of the nodes that are expected to be present in the result set.
+   */
+  protected function assertViewsResult($user_key, array $node_keys) {
+    // Clear the static caches of the cache tags invalidators. The invalidators
+    // will only invalidate cache tags once per request to improve performance.
+    // Unfortunately they cannot distinguish between an actual Drupal page
+    // request and a PHPUnit test that simulates visiting multiple pages.
+    // We are pretending that every time this method is called a new page has
+    // been requested, and the static caches are empty.
+    $this->cacheTagsInvalidator->resetChecksums();
+
+    $this->setCurrentUser($user_key);
+
+    $render_array = $this->getRenderableView();
+    $html = (string) $this->renderer->renderRoot($render_array);
+
+    // Check that the titles of the expected results are present.
+    foreach ($node_keys as $node_key) {
+      $label = $this->nodes[$node_key]->label();
+      $this->assertContains($label, $html);
+    }
+
+    // Also check that none of the titles of the remaining search items are
+    // unexpectedly present.
+    $unexpected_keys = array_diff(array_keys($this->nodes), $node_keys);
+    foreach ($unexpected_keys as $unexpected_key) {
+      $label = $this->nodes[$unexpected_key]->label();
+      $this->assertNotContains($label, $html);
+    }
+  }
+
+  /**
+   * Sets the user with the given key as the currently active user.
+   *
+   * @param string $user_key
+   *   The key of the user to set as currently active user.
+   */
+  protected function setCurrentUser($user_key) {
+    $this->currentUser->setAccount($this->users[$user_key]);
+  }
+
+  /**
+   * Returns the test view as a render array.
+   *
+   * @return array|null
+   *   The render array, or NULL if the view cannot be rendered.
+   */
+  protected function getRenderableView() {
+    $render_array = $this->getView()->buildRenderable();
+    $render_array['#cache']['contexts'] = Cache::mergeContexts($render_array['#cache']['contexts'], $this->container->getParameter('renderer.config')['required_cache_contexts']);
+
+    return $render_array;
+  }
+
+  /**
+   * Returns the test view.
+   *
+   * @return \Drupal\views\ViewExecutable
+   *   The view.
+   */
+  protected function getView() {
+    /** @var \Drupal\views\ViewEntityInterface $view */
+    $view = $this->entityTypeManager->getStorage('view')->load(self::TEST_VIEW_ID);
+    $executable = $this->viewExecutableFactory->get($view);
+    $executable->setDisplay(self::TEST_VIEW_DISPLAY_ID);
+    return $executable;
+  }
+
+  /**
+   * Creates a node with the given title and publication status.
+   *
+   * @param string $title
+   *   The title for the node.
+   * @param bool $status
+   *   The publication status to set.
+   *
+   * @throws \Drupal\Core\Entity\EntityStorageException
+   *   Thrown if an error occurred during the saving of the node.
+   */
+  protected function createNode($title, $status) {
+    $values = [
+      'title' => $title,
+      'status' => $status,
+      'type' => $this->contentType->id(),
+    ];
+    $this->nodes[$title] = Node::create($values);
+    $this->nodes[$title]->save();
+  }
+
+}
diff --git a/tests/src/Kernel/Views/ViewsCacheabilityMetadataExportTest.php b/tests/src/Kernel/Views/ViewsCacheabilityMetadataExportTest.php
new file mode 100644
index 00000000..d7db4fdc
--- /dev/null
+++ b/tests/src/Kernel/Views/ViewsCacheabilityMetadataExportTest.php
@@ -0,0 +1,246 @@
+<?php
+
+namespace Drupal\Tests\search_api\Kernel\Views;
+
+use Drupal\Core\Cache\Context\CacheContextsManager;
+use Drupal\Core\Config\Config;
+use Drupal\Core\DependencyInjection\ContainerBuilder;
+use Drupal\KernelTests\KernelTestBase;
+use Drupal\views\ViewExecutable;
+use Prophecy\Argument;
+
+/**
+ * Tests that cacheability metadata is included when views config is exported.
+ *
+ * @group search_api
+ */
+class ViewsCacheabilityMetadataExportTest extends KernelTestBase {
+
+  /**
+   * The ID of the view used in the test.
+   */
+  const TEST_VIEW_ID = 'search_api_test_node_view';
+
+  /**
+   * The display IDs used in the test.
+   */
+  const TEST_VIEW_DISPLAY_IDS = ['default', 'page_1'];
+
+  /**
+   * The entity type manager.
+   *
+   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   */
+  protected $entityTypeManager;
+
+  /**
+   * The service that is responsible for creating Views executable objects.
+   *
+   * @var \Drupal\views\ViewExecutableFactory
+   */
+  protected $viewExecutableFactory;
+
+  /**
+   * The state service.
+   *
+   * @var \Drupal\Core\State\StateInterface
+   */
+  protected $state;
+
+  /**
+   * {@inheritdoc}
+   */
+  protected static $modules = [
+    'field',
+    'node',
+    'search_api',
+    'search_api_db',
+    'search_api_test_node_indexing',
+    'search_api_test_views',
+    'system',
+    'text',
+    'user',
+    'views',
+  ];
+
+  /**
+   * @inheritDoc
+   */
+  public function register(ContainerBuilder $container) {
+    parent::register($container);
+
+    // Use a mocked version of the cache contexts manager so we can use a mocked
+    // cache context "search_api_test_context" without triggering a validation
+    // error.
+    $cache_contexts_manager = $this->prophesize(CacheContextsManager::class);
+    $cache_contexts_manager->assertValidTokens(Argument::any())->willReturn(TRUE);
+    $container->set('cache_contexts_manager', $cache_contexts_manager->reveal());
+  }
+
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function setUp() {
+    parent::setUp();
+
+    $this->installEntitySchema('node');
+    $this->installEntitySchema('search_api_task');
+
+    $this->installConfig([
+      'search_api',
+      'search_api_test_node_indexing',
+    ]);
+
+    $this->entityTypeManager = $this->container->get('entity_type.manager');
+    $this->viewExecutableFactory = $this->container->get('views.executable');
+    $this->state = $this->container->get('state');
+  }
+
+  /**
+   * Tests that an exported view contains the right cacheability metadata.
+   */
+  public function testViewExport() {
+    $expected_cacheability_metadata = [
+      'contexts' => [
+        // Search API uses the core EntityFieldRenderer for rendering content.
+        // This has support for translatable content, so the result varies by
+        // content language.
+        // @see \Drupal\views\Entity\Render\EntityFieldRenderer::getCacheContexts()
+        'languages:language_content',
+        // By default, Views always adds the interface language cache context
+        // since it is very likely that there will be translatable strings in
+        // the result.
+        // @see \Drupal\views\Entity\View::addCacheMetadata()
+        'languages:language_interface',
+        // Our test view has a pager so we expect it to vary by query arguments.
+        // @see \Drupal\views\Plugin\views\pager\SqlBase::getCacheContexts()
+        'url.query_args',
+        // The test view is a listing of nodes returned as a search result. It
+        // is expected to have the list cache contexts of the node entity type.
+        // This is defined in the "list_cache_contexts" key of the node entity
+        // annotation.
+        'user.node_grants:view',
+      ],
+      'tags' => [
+        // Our test view depends on the search index, so whenever the index
+        // configuration changes the cached results should be invalidated.
+        // @see \Drupal\search_api\Query\Query::getCacheTags()
+        'config:search_api.index.test_node_index',
+      ],
+      // By default the result is permanently cached.
+      'max-age' => -1,
+    ];
+
+    // Check that our test view has the expected cacheability metadata.
+    $view = $this->getView();
+    $this->assertViewCacheabilityMetadata($view, $expected_cacheability_metadata);
+
+    // For efficiency Views calculates the cacheability metadata whenever a view
+    // is saved, and includes it in the exported configuration.
+    // @see \Drupal\views\Entity\View::addCacheMetadata()
+    // Check that the exported configuration contains the expected metadata.
+    $view_config = $this->config('views.view.' . self::TEST_VIEW_ID);
+    $this->assertViewConfigCacheabilityMetadata($view_config, $expected_cacheability_metadata);
+
+    // Test that modules are able to alter the cacheability metadata. Our test
+    // hook implementation will alter all 3 types of metadata.
+    // @see search_api_test_views_search_api_query_alter()
+    $expected_cacheability_metadata['contexts'][] = 'search_api_test_context';
+    $expected_cacheability_metadata['tags'][] = 'search_api:test_tag';
+    $expected_cacheability_metadata['max-age'] = 100;
+
+    // Activate the alter hook and resave the view so it will recalculate the
+    // cacheability metadata.
+    $this->state->set('search_api_test_views.alter_query_cacheability_metadata', TRUE);
+    $view = $this->getView();
+    $view->save();
+
+    // Check that the altered metadata is now present in the view and the
+    // configuration.
+    $view = $this->getView();
+    $this->assertViewCacheabilityMetadata($view, $expected_cacheability_metadata);
+
+    $view_config = $this->config('views.view.' . self::TEST_VIEW_ID);
+    $this->assertViewConfigCacheabilityMetadata($view_config, $expected_cacheability_metadata);
+  }
+
+  /**
+   * Checks that the given view has the expected cacheability metadata.
+   *
+   * @param \Drupal\views\ViewExecutable $view
+   *   The view.
+   * @param array $expected_cacheability_metadata
+   *   An array of cacheability metadata that is expected to be present on the
+   *   view.
+   */
+  protected function assertViewCacheabilityMetadata(ViewExecutable $view, array $expected_cacheability_metadata) {
+    // Cacheability metadata is stored separately for each Views display since
+    // depending on how the display is configured it might have different
+    // caching needs. Ensure to check all displays.
+    foreach (self::TEST_VIEW_DISPLAY_IDS as $display_id) {
+      $view->setDisplay($display_id);
+      $display = $view->getDisplay();
+      $actual_cacheability_metadata = $display->getCacheMetadata();
+
+      $this->assertArrayEquals($expected_cacheability_metadata['contexts'], $actual_cacheability_metadata->getCacheContexts());
+      $this->assertArrayEquals($expected_cacheability_metadata['tags'], $actual_cacheability_metadata->getCacheTags());
+      $this->assertEquals($expected_cacheability_metadata['max-age'], $actual_cacheability_metadata->getCacheMaxAge());
+    }
+  }
+
+  /**
+   * Checks that the given view config has the expected cacheability metadata.
+   *
+   * @param \Drupal\Core\Config\Config $config
+   *   The configuration to check.
+   * @param array $expected_cacheability_metadata
+   *   An array of cacheability metadata that is expected to be present on the
+   *   view configuration.
+   */
+  protected function assertViewConfigCacheabilityMetadata(Config $config, array $expected_cacheability_metadata) {
+    // Cacheability metadata is stored separately for each Views display since
+    // depending on how the display is configured it might have different
+    // caching needs. Ensure to check all displays.
+    foreach (self::TEST_VIEW_DISPLAY_IDS as $display_id) {
+      $view_config_display = $config->get("display.$display_id");
+      foreach ($expected_cacheability_metadata as $cache_key => $value) {
+        if (is_array($value)) {
+          $this->assertArrayEquals($value, $view_config_display['cache_metadata'][$cache_key]);
+        }
+        else {
+          $this->assertEquals($value, $view_config_display['cache_metadata'][$cache_key]);
+        }
+      }
+    }
+  }
+
+  /**
+   * Checks that the given arrays have the same values.
+   *
+   * @param array $array1
+   *   One of the arrays to compare.
+   * @param array $array2
+   *   One of the arrays to compare.
+   */
+  protected function assertArrayEquals(array $array1, array $array2) {
+    sort($array1);
+    sort($array2);
+    $this->assertEquals($array1, $array2);
+  }
+
+  /**
+   * Returns the test view.
+   *
+   * @return \Drupal\views\ViewExecutable
+   *   The view.
+   */
+  protected function getView() {
+    /** @var \Drupal\views\ViewEntityInterface $view */
+    $view = $this->entityTypeManager->getStorage('view')->load(self::TEST_VIEW_ID);
+    $executable = $this->viewExecutableFactory->get($view);
+
+    return $executable;
+  }
+
+}
diff --git a/tests/src/Kernel/Views/ViewsDisplayCachingTest.php b/tests/src/Kernel/Views/ViewsDisplayCachingTest.php
index ce6d8505..9d669d6a 100644
--- a/tests/src/Kernel/Views/ViewsDisplayCachingTest.php
+++ b/tests/src/Kernel/Views/ViewsDisplayCachingTest.php
@@ -317,15 +317,16 @@ class ViewsDisplayCachingTest extends KernelTestBase {
       // Views. This is expected to disable caching.
       [
         'none',
-        // It is expected that only the configuration of the view itself is
-        // available as a cache tag.
+        // Cache tags for index and view config are included at the query level,
+        // so should still be present even when disabling caching.
         [
+          'config:search_api.index.database_search_index',
           'config:views.view.search_api_test_cache',
         ],
         // No specific cache contexts are expected to be present.
         [],
-        // It is expected that the cache max-age is set to zero, effectively
-        // disabling the cache.
+        // The cache max-age should be returned as zero, effectively disabling
+        // the cache.
         0,
         // It is expected that no results are cached.
         FALSE,
@@ -337,9 +338,9 @@ class ViewsDisplayCachingTest extends KernelTestBase {
       [
         'tag',
         [
-          // It is expected that the configuration of the view itself is
-          // available as a cache tag, so that the caches are invalidated if the
-          // view configuration changes.
+          // The cache should be invalidated when either index or view are
+          // modified.
+          'config:search_api.index.database_search_index',
           'config:views.view.search_api_test_cache',
           // The view shows an entity, so it should be invalidated when that
           // entity changes.
@@ -362,9 +363,9 @@ class ViewsDisplayCachingTest extends KernelTestBase {
       [
         'time',
         [
-          // It is expected that the configuration of the view itself is
-          // available as a cache tag, so that the caches are invalidated if the
-          // view configuration changes. No other tags should be available.
+          // The cache should be invalidated when either index or view are
+          // modified.
+          'config:search_api.index.database_search_index',
           'config:views.view.search_api_test_cache',
         ],
         // No specific cache contexts are expected to be present.
diff --git a/tests/src/Kernel/Views/ViewsPropertyExtractionTest.php b/tests/src/Kernel/Views/ViewsPropertyExtractionTest.php
index 160ad068..b38c6153 100644
--- a/tests/src/Kernel/Views/ViewsPropertyExtractionTest.php
+++ b/tests/src/Kernel/Views/ViewsPropertyExtractionTest.php
@@ -91,14 +91,23 @@ class ViewsPropertyExtractionTest extends KernelTestBase {
         }
       };
     };
-    $value1 = $processor_property_value ?: 'Processor 1';
     $processor1 = $this->createMock(ProcessorInterface::class);
-    $processor1->method('addFieldValues')
-      ->willReturnCallback($generate_add_field_values($value1));
-    $value2 = $processor_property_value ?: 'Processor 2';
     $processor2 = $this->createMock(ProcessorInterface::class);
-    $processor2->method('addFieldValues')
-      ->willReturnCallback($generate_add_field_values($value2));
+    // When we pre-set the row values we don't expect the processor to be called
+    // for field value extraction.
+    if ($pre_set) {
+      $exception = new \Exception('Should not be called.');
+      $processor1->method('addFieldValues')->willThrowException($exception);
+      $processor2->method('addFieldValues')->willThrowException($exception);
+    }
+    else {
+      $value1 = $processor_property_value ?: 'Processor 1';
+      $processor1->method('addFieldValues')
+        ->willReturnCallback($generate_add_field_values($value1));
+      $value2 = $processor_property_value ?: 'Processor 2';
+      $processor2->method('addFieldValues')
+        ->willReturnCallback($generate_add_field_values($value2));
+    }
     $index->method('getProcessor')->willReturnMap([
       ['processor1', $processor1],
       ['processor2', $processor2],
@@ -148,7 +157,6 @@ class ViewsPropertyExtractionTest extends KernelTestBase {
     ];
     $field = new SearchApiStandard($configuration, '', []);
     $options = [
-      'link_to_item' => TRUE,
       'use_highlighting' => TRUE,
     ];
     $field->init($view, $display, $options);
@@ -167,22 +175,15 @@ class ViewsPropertyExtractionTest extends KernelTestBase {
         NULL => [$object],
       ],
     ]);
+    // For the configurable property, change the property path if it matches a
+    // field.
+    if ($property_path === 'entity:user/property2') {
+      $original_property_path = $property_path;
+      $property_path = "$property_path|test";
+    }
     if ($pre_set) {
       $row->$property_path = ['Pre-set'];
     }
-    // For the configurable property, also set the values for the special
-    // property path.
-    if ($property_path === 'entity:user/property2') {
-      $special_path = "$property_path|test";
-      if ($pre_set) {
-        $row->$special_path = ['Pre-set'];
-      }
-      // Whether that special property path will actually be used by the field
-      // plugin depends on whether it finds a matching field.
-      if ($return_fields) {
-        $property_path = $special_path;
-      }
-    }
     if ($set_highlighting) {
       $item->setExtraData('highlighted_fields', [
         'test' => [
@@ -194,7 +195,21 @@ class ViewsPropertyExtractionTest extends KernelTestBase {
 
     $field->preRender($values);
 
+    $this->assertTrue(isset($row->$property_path), "\"$property_path\" property is set on \$row");
     $this->assertEquals((array) $expected, $row->$property_path);
+
+    // Check that $field->propertyReplacements was set correctly (if
+    // applicable).
+    $property_replacements = new \ReflectionProperty($field, 'propertyReplacements');
+    $property_replacements->setAccessible(TRUE);
+    $property_replacements = $property_replacements->getValue($field);
+    if (isset($original_property_path)) {
+      $this->assertArrayHasKey($original_property_path, $property_replacements);
+      $this->assertEquals($property_path, $property_replacements[$original_property_path]);
+    }
+    else {
+      $this->assertEmpty($property_replacements);
+    }
   }
 
   /**
diff --git a/tests/src/Unit/Processor/AddURLTest.php b/tests/src/Unit/Processor/AddURLTest.php
index 0372178f..1e0f95ef 100644
--- a/tests/src/Unit/Processor/AddURLTest.php
+++ b/tests/src/Unit/Processor/AddURLTest.php
@@ -50,7 +50,7 @@ class AddURLTest extends UnitTestCase {
       ->method('toString')
       ->will($this->returnValue('http://www.example.com/node/example'));
 
-    // Mock the data source of the indexer to return the mocked url object.
+    // Mock the datasource of the indexer to return the mocked url object.
     $datasource = $this->createMock(DatasourceInterface::class);
     $datasource->expects($this->any())
       ->method('getItemUrl')
