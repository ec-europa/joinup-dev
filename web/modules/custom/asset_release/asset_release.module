<?php

/**
 * @file
 * Contains hooks regarding the asset_release rdf entity bundle.
 */

declare(strict_types = 1);

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\StringTranslation\TranslatableMarkup;
use Drupal\asset_release\Entity\AssetRelease;
use Drupal\asset_release\Entity\AssetReleaseInterface;
use Drupal\rdf_entity\RdfInterface;
use Drupal\sparql_entity_storage\SparqlGraphInterface;

/**
 * Implements hook_entity_type_alter().
 *
 * Adds the solution releases overview page as link template so the OG context
 * can be resolved automatically.
 */
function asset_release_entity_type_alter(array &$entity_types) {
  $entity_types['rdf_entity']->setLinkTemplate('solution-releases', '/rdf_entity/{rdf_entity}/releases');
}

/**
 * Implements hook_entity_bundle_info_alter().
 */
function asset_release_entity_bundle_info_alter(&$bundles) {
  if (!empty($bundles['rdf_entity']['asset_release'])) {
    $bundles['rdf_entity']['asset_release']['class'] = AssetRelease::class;
  }
}

/**
 * Implements hook_entity_bundle_field_info_alter().
 */
function asset_release_entity_bundle_field_info_alter(&$fields, EntityTypeInterface $entity_type, $bundle) {
  /** @var \Drupal\Core\Field\FieldConfigInterface[] $fields */
  // Make sure a release's title and version number is unique in its solution.
  if ($entity_type->id() == 'rdf_entity' && $bundle == 'asset_release' && !empty($fields['label'])) {
    $fields['label']->addConstraint('UniqueAssetReleaseTitleVersion', []);
  }

  // A distribution can be referenced only by a single parent.
  if (!empty($fields['field_isr_distribution'])) {
    $fields['field_isr_distribution']->addConstraint('DistributionSingleParent');
  }
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 *
 * This takes care of the reverse reference. When a release is created, it has
 * its isVersionOf pre-filled and is connected to its parent. But the parent
 * needs to have the hasVersion field filled as well.
 */
function asset_release_rdf_entity_insert(RdfInterface $release) {
  if ($release->bundle() === 'asset_release') {
    /** @var \Drupal\Core\Field\EntityReferenceFieldItemListInterface $is_version_of */
    $is_version_of = $release->get('field_isr_is_version_of');
    /** @var \Drupal\rdf_entity\RdfInterface $solution */
    if (!$is_version_of->isEmpty() && ($solution = $is_version_of->entity)) {
      if ($solution->bundle() !== 'solution') {
        throw new \Exception("Entity '{$solution->label()}' ({$solution->id()}) is a '{$solution->bundle()}' but it should be 'solution' to be set as parent of release '{$release->label()}' ({$release->id()}).");
      }

      $parent_is_set = FALSE;
      /** @var \Drupal\Core\Field\EntityReferenceFieldItemListInterface $has_version */
      $has_version = $solution->get('field_is_has_version');
      foreach ($has_version as $field_item) {
        if ($field_item->target_id === $release->id()) {
          $parent_is_set = TRUE;
          break;
        }
      }
      if (!$parent_is_set) {
        $has_version->appendItem(['target_id' => $release->id()]);
        // Avoid triggering notification e-mails during this update.
        $solution->skip_notification = TRUE;
        $solution->save();
      }
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_update().
 */
function asset_release_rdf_entity_update(EntityInterface $entity) {
  if ($entity->bundle() !== 'solution') {
    return;
  }

  $release_relations = \Drupal::service('asset_release.relations');
  /** @var \Drupal\Core\Field\EntityReferenceFieldItemListInterface $has_version */
  $has_version = $entity->get('field_is_has_version');
  foreach ($has_version->referencedEntities() as $release) {
    // Synchronize common fields of child release from parent solution.
    if ($release_relations->syncFieldsFromParentSolution($release)) {
      // Do not send emails for this change.
      $release->skip_notification = TRUE;
      $release->save();
      unset($release->skip_notification);
    }
  }
}

/**
 * Implements hook_preprocess_HOOK().
 */
function asset_release_preprocess_rdf_entity(array &$variables): void {
  $release = $variables['rdf_entity'];
  if (!$release instanceof AssetReleaseInterface) {
    return;
  }
  $variables['full_label'] = new TranslatableMarkup('@label @version', [
    '@label' => $release->label(),
    '@version' => $release->getVersion(),
  ]);

  $solution = $release->getSolution();
  $variables['is_latest_release'] = $release->isLatestRelease();

  // Whenever a new release gets created, the parent solution gets updated.
  // Invalidate the rendered template cache of the latest release in that case,
  // so the latest release flag gets updated.
  if ($solution && $variables['is_latest_release']) {
    $cache_tags = isset($variables['#cache']['tags']) ? $variables['#cache']['tags'] : [];
    $cache_tags = Cache::mergeTags($cache_tags, $solution->getCacheTags());

    // Add the group content tag belonging to the parent too. We need to
    // invalidate the cache also when a release is first saved as draft and then
    // published. In that case the solution won't be updated, so we need to
    // manually take care of this.
    $group_tag = Cache::buildTags('og-group-content', $solution->getCacheTagsToInvalidate());
    $variables['#cache']['tags'] = Cache::mergeTags($cache_tags, $group_tag);
  }
}

/**
 * Implements hook_theme().
 */
function asset_release_theme($existing, $type, $theme, $path) {
  return [
    'asset_release_releases_download' => [
      'variables' => ['releases' => []],
    ],
  ];
}

/**
 * Implements hook_ENTITY_TYPE_access().
 *
 * Interrupts the permissions for updating a release. The permission is not
 * granted if there are no transitions allowed for the current state of the
 * node.
 */
function asset_release_rdf_entity_access(EntityInterface $release, $operation, AccountInterface $account) {
  if (!$release instanceof AssetReleaseInterface || $account->hasPermission($release->getEntityType()->getAdminPermission())) {
    return AccessResult::neutral();
  }

  switch ($operation) {
    case 'view':
      $parent = $release->getSolution();

      // If for any reason access is requested to an entity without a parent,
      // deny that access.
      if (empty($parent)) {
        return AccessResult::forbidden();
      }

      /** @var \Drupal\Core\Entity\EntityAccessControlHandlerInterface $access_handler */
      $access_handler = \Drupal::service('entity_type.manager')->getAccessControlHandler('rdf_entity');
      if (!$access_handler->access($parent, 'view', $account)) {
        return AccessResult::forbidden();
      }

      $membership = $parent->getMembership((int) $account->id());
      if (empty($membership)) {
        return AccessResult::neutral();
      }
      if (!$release->isPublished() && $membership->hasPermission('view unpublished rdf entity')) {
        return AccessResult::allowed();
      }
      if ($release->isPublished() && $membership->hasPermission('view rdf entity')) {
        return AccessResult::allowed();
      }
      break;

    case 'edit':
      /** @var \Drupal\joinup_workflow\WorkflowHelperInterface $workflow_helper */
      $workflow_helper = \Drupal::service('joinup_workflow.workflow_helper');
      $allowed_states = $workflow_helper->getAvailableTargetStates($release, $account);
      return AccessResult::forbiddenIf(empty($allowed_states));

    case 'delete':
      // In Joinup, only moderators can delete releases. The following check
      // will add a forbidden opinion in the delete access check if the user
      // does not have a global delete permission to override OG group admin
      // privileges.
      return AccessResult::forbiddenIf(!$account->hasPermission('delete asset_release rdf entity'));
  }

  return AccessResult::neutral();
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 *
 * Default graph is published. Draft graph is draft.
 */
function asset_release_rdf_entity_presave(EntityInterface $entity) {
  if (!$entity instanceof AssetReleaseInterface) {
    // Act only on releases.
    return;
  }

  if (!$entity->get('field_isr_is_version_of')->isEmpty()) {
    // Synchronize common fields from parent solution.
    \Drupal::service('asset_release.relations')->syncFieldsFromParentSolution($entity);
  }

  if (!\Drupal::service('sparql.graph_handler')->bundleHasGraph('rdf_entity', 'asset_release', 'draft')) {
    return;
  }

  // Set the graph only for new releases or those loaded from the main graphs.
  if (!$entity->isNew() && !in_array(
    $entity->sparqlEntityOriginalGraph,
    ['default', 'draft']
  )) {
    return;
  }

  $state = $entity->getWorkflowState();
  if (in_array($state, ['draft', 'needs_update'])) {
    $entity->set('graph', 'draft');
  }
  elseif (in_array($state, ['validated'])) {
    $entity->set('graph', SparqlGraphInterface::DEFAULT);
  }
  elseif (empty($state)) {
    throw new \Exception('State field not found while trying to get the appropriate graph.');
  }
  else {
    throw new \Exception("State field value is invalid. Current value found: $state");
  }
}

/**
 * Implements hook_entity_update().
 *
 * Performs the following actions:
 * - When the entity is saved into the default graph, the draft must be deleted.
 */
function asset_release_entity_update(EntityInterface $entity) {
  // Quick escape check to avoid unnecessary loadings.
  if ($entity->bundle() !== 'asset_release' || !\Drupal::service('sparql.graph_handler')->bundleHasGraph('rdf_entity', 'asset_release', 'draft')) {
    return;
  }

  if ($entity->field_isr_state->value === 'validated') {
    \Drupal::entityTypeManager()->getStorage('rdf_entity')->deleteFromGraph([$entity], 'draft');
  }
}

/**
 * Prepares variables for the 'asset_release_releases_download' template.
 *
 * @param array $variables
 *   An associative array containing:
 *   - releases: a list of releases and distributions to be rendered.
 */
function template_preprocess_asset_release_releases_download(array &$variables) {
  $releases = $variables['releases'];

  $variables['releases'] = \Drupal::entityTypeManager()->getViewBuilder('rdf_entity')->viewMultiple($releases, 'compact');
}

/**
 * Checks if the given release has a unique combination of title and version.
 *
 * A solution might have releases of different software packages associated with
 * it, and some of these might have duplicate version numbers, but to avoid
 * confusion we should avoid having releases with identical names and versions
 * within the same solution.
 *
 * @param \Drupal\asset_release\Entity\AssetReleaseInterface $asset_release
 *   The release to check.
 * @param bool $check_unaffiliated_solutions
 *   Whether or not to check if the release title and version are unique in
 *   solutions that are not related to the release.
 *   - When this is TRUE the function will return TRUE if any other release has
 *     the same title and version as the given release, regardless of the
 *     solutions they are affiliated with.
 *   - When this is FALSE the function will only return TRUE if the solution
 *     that is affiliated with this release contains a release with a duplicate
 *     title and version. Releases that belong to unaffiliated solutions will be
 *     ignored.
 *
 * @return bool
 *   TRUE if the title and version are unique.
 */
function asset_release_title_version_is_unique(AssetReleaseInterface $asset_release, $check_unaffiliated_solutions = FALSE) {
  $query = \Drupal::entityQuery('rdf_entity')
    ->condition('label', $asset_release->label())
    ->condition('field_isr_release_number', $asset_release->getVersion())
    ->condition('rid', 'asset_release');
  if (!empty($asset_release->id())) {
    $query->condition('id', $asset_release->id(), '<>');
  }

  // Filter all releases that do not belong to the same solution.
  if (!$check_unaffiliated_solutions) {
    $query->condition('field_isr_is_version_of', $asset_release->get('field_isr_is_version_of')->first()->getValue()['target_id']);
  }

  $result = $query->execute();

  return empty($result);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function asset_release_form_rdf_entity_asset_release_delete_form_alter(array &$form, FormStateInterface $form_state, string $form_id) {
  $form['actions']['submit']['#submit'][] = 'asset_release_delete_redirect';
}

/**
 * Redirect users to the solution homepage after deleting a release.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function asset_release_delete_redirect(array &$form, FormStateInterface $form_state) {
  /** @var \Drupal\asset_release\Entity\AssetReleaseInterface $release */
  $release = $form_state->getFormObject()->getEntity();
  $solution = $release->getSolution();
  if (!empty($solution)) {
    $url = $solution->toUrl();
    $form_state->setRedirect($url->getRouteName(), $url->getRouteParameters(), $url->getOptions());
  }
}

/**
 * Implements hook_preprocess_page_title__rdf_entity__asset_release().
 */
function asset_release_preprocess_page_title__rdf_entity__asset_release(array &$variables): void {
  /** @var \Drupal\asset_release\Entity\AssetReleaseInterface $release */
  $release = $variables['entity'];

  $variables['additional_content']['full_label'] = new TranslatableMarkup('@label @version', [
    '@label' => $release->label(),
    '@version' => $release->getVersion(),
  ]);

  $is_latest_release = $release->isLatestRelease();
  $variables['additional_content']['is_latest_release'] = $is_latest_release;
  if (!$is_latest_release && ($latest_release = $release->getSolution()->getLatestRelease())) {
    $variables['additional_content']['latest_release'] = $latest_release->toUrl()->toString();
  }

  // Get the view builder service from the entity type manager.
  $view_builder = \Drupal::entityTypeManager()->getViewBuilder('rdf_entity');
  // Get the creation date field.
  $creation_date = $release->get('created');
  $creation_date = $view_builder->viewField($creation_date, 'default');
  $variables['additional_content']['created'] = $creation_date;
}
