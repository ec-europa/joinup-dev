<?php

/**
 * @file
 * Hook implementations for the Joinup Group module.
 */

declare(strict_types = 1);

use Drupal\Component\Serialization\Json;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Cache\CacheableMetadata;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Test\Exception\MissingGroupException;
use Drupal\Core\Url;
use Drupal\file\Entity\File;
use Drupal\joinup_group\Entity\GroupContentInterface;
use Drupal\joinup_group\Entity\GroupInterface;
use Drupal\joinup_group\Event\GroupMenuLinksEvent;
use Drupal\joinup_group\Form\RdfDeleteForm;
use Drupal\joinup_group\JoinupGroupHelper;
use Drupal\joinup_workflow\EntityWorkflowStateInterface;
use Drupal\meta_entity\Entity\MetaEntityInterface;
use Drupal\node\NodeInterface;
use Drupal\og\OgAccess;
use Drupal\og\OgGroupAudienceHelperInterface;
use Drupal\og\OgMembershipInterface;
use Drupal\og_menu\Entity\OgMenuInstance;
use Drupal\rdf_entity\RdfInterface;
use Drupal\search_api\Plugin\search_api\datasource\ContentEntity;
use Drupal\user\UserInterface;
use Drupal\views\Plugin\views\query\QueryPluginBase;
use Drupal\views\Plugin\views\query\Sql;
use Drupal\views\ViewExecutable;
use Drupal\views\Views;

/**
 * Implements hook_theme().
 */
function joinup_group_theme($existing, $type, $theme, $path) {
  return [
    // A button that (when clicked) opens a dropdown that (when clicked) opens a
    // modal with a confirmation button that (when clicked) allows the user to
    // leave the group.
    'group_leave_button' => [
      'variables' => [
        'confirm' => '',
      ],
    ],
  ];
}

/**
 * Implements hook_entity_bundle_field_info_alter().
 */
function joinup_group_entity_bundle_field_info_alter(array &$fields, EntityTypeInterface $entity_type, string $bundle): void {
  if ($entity_type->id() === 'rdf_entity' && in_array($bundle, JoinupGroupHelper::GROUP_BUNDLES)) {
    if (!empty($fields['field_short_id'])) {
      /** @var \Drupal\field\Entity\FieldConfig[] $fields */
      $fields['field_short_id']->addPropertyConstraints('value', [
        'Regex' => ['pattern' => '/^[a-z0-9-]{4,26}$/'],
      ]);
      $fields['field_short_id']->addConstraint('UniqueShortIdInsensitive');
    }
  }
}

/**
 * Implements hook_preprocess_HOOK() for the main menu.
 *
 * Sets the active trail for the main menu items based on the current group
 * context.
 */
function joinup_group_preprocess_menu__main(&$variables) {
  $group = \Drupal::service('og.context')->getGroup();
  if ($group) {
    /** @var \Drupal\Core\Entity\ContentEntityInterface $group */
    switch ($group->bundle()) {
      case 'collection':
        $variables['items']['views_view:views.collections.page_1']['in_active_trail'] = TRUE;
        break;

      case 'solution':
        $variables['items']['views_view:views.solutions.page_1']['in_active_trail'] = TRUE;
        break;
    }
  }

  $variables['#cache']['contexts'][] = 'og_group_context';
  $variables['#cache']['contexts'][] = 'url.path';
}

/**
 * Implements hook_preprocess_page().
 *
 * Adds the current og group context as attribute on the page wrapper.
 */
function joinup_group_preprocess_page(&$variables) {
  /** @var \Drupal\Core\Plugin\Context\ContextInterface[] $context */
  $context = \Drupal::service('og.context')->getRuntimeContexts(['og']);

  if (!empty($context['og'])) {
    $group = $context['og']->getContextValue();

    if ($group && $group->getEntityTypeId() === 'rdf_entity') {
      $variables['attributes']['data-drupal-group-context'] = $group->id();
    }
  }
}

/**
 * Implements hook_entity_type_alter().
 */
function joinup_group_entity_type_alter(array &$entity_types) {
  // Swap the default user cancel form implementation with a custom one that
  // prevents deleting users when they are the sole owner of a group.
  $entity_types['user']->setFormClass('cancel', 'Drupal\joinup_group\Form\UserCancelForm');

  // Override the delete form to disallow deletion of groups with children.
  /** @var \Drupal\Core\Entity\ContentEntityTypeInterface $rdf_entity_type */
  if (array_key_exists('rdf_entity', $entity_types)) {
    $rdf_entity_type = $entity_types['rdf_entity'];
    $rdf_entity_type->setFormClass('delete', RdfDeleteForm::class);
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * Adds a submit handler that will show a message to the user after proposing a
 * collection or solution.
 */
function joinup_group_form_rdf_entity_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  /** @var \Drupal\rdf_entity\Form\RdfForm $form_object */
  $form_object = $form_state->getFormObject();
  /** @var \Drupal\rdf_entity\RdfInterface $entity */
  $entity = $form_object->getEntity();

  // Add submit callback when the current bundle is in the list and when we are
  // in an affected operation type.
  $operation_types = ['add', 'default', 'propose'];
  if ($entity instanceof GroupInterface && in_array($form_object->getOperation(), $operation_types)) {
    $form['actions']['submit']['#submit'][] = 'joinup_group_propose_message_submit';
  }

  if ($entity instanceof GroupInterface) {
    // If the entity has been published, only moderators can edit the short ID.
    // @todo Implement the EntityPublishedInterface for collections and
    //   solutions once we have the bundle classes in.
    $has_published_version = $entity->hasGraph('default');
    if (isset($form['field_short_id']) && $has_published_version && !\Drupal::currentUser()->hasPermission('edit short id after publication')) {
      $form['field_short_id']['widget'][0]['value']['#attributes']['disabled'] = 'disabled';
    }
  }
}

/**
 * Submit callback for the propose form of a collection or solution.
 *
 * Informs the user that a newly proposed collection or solution needs approval.
 */
function joinup_group_propose_message_submit(&$form, FormStateInterface $form_state) {
  $form_object = $form_state->getFormObject();
  $entity = $form_object->getEntity();
  if ($entity instanceof EntityWorkflowStateInterface) {
    if ($entity->getWorkflowState() === 'proposed') {
      \Drupal::messenger()->addStatus(t('Thank you for proposing a @entity_label. Your request is currently pending approval by the site administrator.', ['@entity_label' => $entity->get('rid')->entity->getSingularLabel()]));
    }
  }
}

/**
 * Implements hook_entity_graph_access().
 *
 * The same procedure as the global access check is followed here. The purpose
 * is to override the results of the global access check if the user has the
 * appropriate OG permissions.
 *
 * @todo hook api definition is needed.
 */
function joinup_group_entity_graph_access(EntityInterface $entity, string $operation, AccountInterface $account, string $graph_name): AccessResult {
  if (!$entity || !$entity instanceof GroupInterface || $operation != 'view' || $graph_name == 'default') {
    return AccessResult::neutral();
  }

  $membership = $entity->getMembership((int) $account->id());
  if (empty($membership)) {
    return AccessResult::neutral();
  }

  // Following the same logic as the global access check.
  $map = ['view' => 'view all graphs'];
  $entity_type_id = $entity->getEntityTypeId();
  $type_map = ['view' => "view $entity_type_id $graph_name graph"];

  // If the operation is not supported, do not allow access.
  if (!isset($map[$operation]) || !isset($type_map[$operation])) {
    return AccessResult::forbidden();
  }

  $has_permission = $membership->hasPermission($map[$operation]) || $membership->hasPermission($type_map[$operation]);
  return $has_permission ? AccessResult::allowed() : AccessResult::neutral();
}

/**
 * Implements hook_ENTITY_TYPE_insert() for RDF entities.
 */
function joinup_group_rdf_entity_insert(RdfInterface $group): void {
  if (!$group instanceof GroupInterface) {
    return;
  }

  // When a group is created, create a new navigation menu and associate it with
  // the new collection or solution. This menu can be used to link to custom
  // pages, member overviews, an about page, etc.
  $og_menu_instance = OgMenuInstance::create([
    'type' => 'navigation',
    OgGroupAudienceHelperInterface::DEFAULT_FIELD => $group->id(),
  ]);
  $og_menu_instance->save();
  $menu_name = 'ogmenu-' . $og_menu_instance->id();

  /** @var \Symfony\Component\EventDispatcher\EventDispatcherInterface $event_dispatcher */
  $event_dispatcher = \Drupal::service('event_dispatcher');

  // Allow third-party to add group menu links.
  $event = new GroupMenuLinksEvent($group, $menu_name, \Drupal::entityTypeManager());
  $event_dispatcher->dispatch($event::ADD_LINKS, $event);
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 *
 * Provide default images for collections and solutions in case they are empty.
 */
function joinup_group_rdf_entity_presave(EntityInterface $entity) {
  if (!$entity instanceof GroupInterface) {
    return;
  }

  $field_data = [
    'logo' => ['field_ar_logo', 'field_is_logo'],
    'banner' => ['field_ar_banner', 'field_is_banner'],
  ];

  $file_system = \Drupal::service('file_system');
  $fixtures_path = drupal_get_path('module', 'joinup_group') . '/fixtures/images/';
  foreach ($field_data as $field_type => $fields) {
    foreach ($fields as $field) {
      if ($entity->hasField($field) && empty($entity->get($field)->getValue())) {
        // Get files without the . and .. directories.
        $files = array_slice(scandir($fixtures_path . $field_type), 2);
        $random = array_rand($files);
        $file_path = $file_system->realpath($fixtures_path . $field_type . '/' . $files[$random]);
        $file_path = $file_system->copy($file_path, 'public://');
        $file = File::create(['uri' => $file_path]);
        $file->save();
        $entity->set($field, $file->id());
      }
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_update().
 *
 * Re-index all group content when a group is saved with a changed status.
 *
 * The hasPublished flag ensures that this will occur only when an entity is
 * published for the first time.
 *
 * @see \joinup_group_rdf_entity_presave()
 */
function joinup_group_rdf_entity_update(EntityInterface $entity) {
  if (!$entity instanceof GroupInterface) {
    return;
  }

  if ($entity->isPublished() && isset($entity->hasPublished) && $entity->hasPublished === FALSE) {
    /** @var \Drupal\og\MembershipManagerInterface $membership_manager */
    $membership_manager = \Drupal::service('og.membership_manager');
    $content_ids = $membership_manager->getGroupContentIds($entity, ['node']);
    $nodes = \Drupal::entityTypeManager()->getStorage('node')->loadMultiple($content_ids['node']);
    /** @var \Drupal\node\NodeInterface $node */
    foreach ($nodes as $node) {
      ContentEntity::indexEntity($node);
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_update().
 *
 * Make sure that when an entity is (un)pinned it is reindexed and its caches
 * are invalidated.
 *
 * Note that this duplicates code for featuring entities in the joinup_featured
 * module. This was considered a better solution that introducing some awkward
 * dependency between the two modules. The code is trivial and most can be
 * removed when the cache of the parent entity is invalidated automatically by
 * the Meta Entity module.
 *
 * @see https://www.drupal.org/project/meta_entity/issues/3169560
 */
function joinup_group_meta_entity_update(MetaEntityInterface $entity): void {
  if ($entity->bundle() === 'pinned_in') {
    $parent_entity = $entity->getTargetEntity();
    if (empty($parent_entity)) {
      // If the parent entity no longer exists nothing needs to be done. This
      // can happen if this is called via joinup_group_meta_entity_delete() as
      // part of an orphan cleanup.
      return;
    }

    // Invalidate the entity storage cache of the parent entity, this ensures
    // that we are reindexing the updated values of the parent entity.
    \Drupal::entityTypeManager()->getStorage($parent_entity->getEntityTypeId())->resetCache([$parent_entity->id()]);

    // Reindex the parent entity since the pinned status affects the ordering of
    // search results: pinned entities are shown at the top.
    ContentEntity::indexEntity($parent_entity);

    // Invalidate caches of the parent entity so that the pin icon will be shown
    // or hidden according to the new pinned status.
    // @todo Remove this workaround once Meta Entity clears list cache tags.
    // @see https://www.drupal.org/project/meta_entity/issues/3169560
    Cache::invalidateTags($parent_entity->getCacheTagsToInvalidate());
  }
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 *
 * @see joinup_group_meta_entity_update()
 */
function joinup_group_meta_entity_insert(MetaEntityInterface $entity): void {
  joinup_group_meta_entity_update($entity);
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 *
 * @see joinup_group_meta_entity_update()
 */
function joinup_group_meta_entity_delete(MetaEntityInterface $entity): void {
  joinup_group_meta_entity_update($entity);
}

/**
 * Implements hook_og_user_access_alter().
 */
function joinup_group_og_user_access_alter(array &$permissions, CacheableMetadata &$cacheable_metadata, array $context): void {
  $group = $context['group'];
  $user = $context['user'];

  // Group owners are allowed to delete their own groups when they are in
  // validated state.
  // @todo Also allow groups to be deleted in any state other than 'archived'.
  // @see https://citnet.tech.ec.europa.eu/CITnet/jira/browse/ISAICP-6088
  $permission = $context['permission'];
  if ($permission !== OgAccess::DELETE_GROUP_PERMISSION) {
    return;
  }

  // Only act on entities that are groups and subject to workflow.
  if (!$group instanceof GroupInterface || !$group instanceof EntityWorkflowStateInterface) {
    return;
  }

  // Skip if the group is not in validated state.
  if ($group->getWorkflowState() !== 'validated') {
    return;
  }

  // Check if the user is the group owner and bail out if this is not the case.
  if (!$group->isGroupOwner((int) $user->id())) {
    return;
  }

  // All conditions are met. Grant permission to delete the group.
  $permissions[] = OgAccess::DELETE_GROUP_PERMISSION;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Adds result counts to the role options on the membership overview for
 * collections and solutions.
 */
function joinup_group_form_views_exposed_form_alter(&$form, FormStateInterface $form_state) {
  /** @var \Drupal\views\ViewExecutable $view */
  $view = $form_state->get('view');
  $view_id = $view->id();
  if (!in_array($view_id, ['members_overview', 'og_members_overview'])) {
    return;
  }

  // Bail out if we are executing the views queries that get the result counts.
  if (!empty($view->do_not_recurse)) {
    return;
  }

  // Retrieve the collection or solution for which the membership overview is
  // being built.
  $group = \Drupal::entityTypeManager()->getStorage($view->args[0])->load($view->args[1]);

  // Define a function that gets the result count for a given exposed filter
  // option.
  $get_result_count = function ($view_id, $display_id, $arguments, $exposed_option, array $exposed_input) {
    /** @var \Drupal\views\ViewExecutable $view */
    $view = Views::getView($view_id);
    // Make sure we do not get into an endless loop when building the view,
    // since it will try to build the exposed form again.
    $view->do_not_recurse = TRUE;
    // When the exposed input is not set then Views will take the values from
    // the request arguments. If we want to override them with "there is no
    // exposed input" then we need to pass a value that is not considered empty,
    // hence we use "[TRUE]" instead of "[]".
    $exposed_input['roles_target_id'] = $exposed_option ?: TRUE;
    $view->setExposedInput($exposed_input);
    $view->executeDisplay($display_id, $arguments);
    // Apparently it is not guaranteed that the `total_rows` will be populated.
    // @see \Drupal\views\Plugin\views\area\Result::render()
    return isset($view->total_rows) ? $view->total_rows : count($view->result);
  };

  /** @var \Drupal\views\Plugin\views\filter\StringFilter $filter */
  $filter = $view->filter['roles_target_id'];
  $group_items = $filter->options['group_info']['group_items'];

  // Check all options, as well as the "- Any -" option.
  $exposed_options = array_merge([NULL], array_keys($group_items));

  foreach ($exposed_options as $exposed_option) {
    // We have different roles for collections and solutions, only keep the
    // relevant ones.
    if (!empty($exposed_option) && strpos($group_items[$exposed_option]['value'], $group->bundle()) === FALSE) {
      unset($form['roles_target_id']['#options'][$exposed_option]);
    }
    else {
      $count = $get_result_count($view_id, $view->getDisplay()->getPluginId(), $view->args, $exposed_option, $view->getExposedInput());
      $key = $exposed_option ?: 'All';
      $option_text = (string) $form['roles_target_id']['#options'][$key];
      $form['roles_target_id']['#options'][$key] = "$option_text ($count)";
    }
  }

  // Insert a link to the table showing member permissions.
  $url = Url::fromRoute('joinup_group.membership_permissions_info', [
    'rdf_entity' => $group->id(),
  ]);
  $form['member_permissions_link'] = [
    '#type' => 'link',
    '#title' => t('Member permissions'),
    '#url' => $url,
    '#attributes' => [
      'class' => ['use-ajax'],
      'data-dialog-type' => 'modal',
      'data-dialog-options' => Json::encode([
        'width' => 'auto',
        'height' => 'auto',
      ]),
    ],
    '#access' => $url->access(),
    '#attached' => ['library' => ['core/drupal.dialog.ajax']],
  ];
}

/**
 * Implements hook_views_query_alter().
 */
function joinup_group_views_query_alter(ViewExecutable $view, QueryPluginBase $query): void {
  // In the member administration bulk operation view we are formatting the
  // username column as full names, but Views still sorts by username. Make sure
  // we sort by first name + last name instead of by username.
  if ($view->id() === 'og_members_overview' && $query instanceof Sql) {
    // Skip if we're not ordering by username.
    if (empty($query->orderby[0]['field'])) {
      return;
    }
    $field = $query->orderby[0]['field'];
    if ($field !== 'users_field_data_og_membership.name') {
      return;
    }

    $display = $view->getDisplay();

    // Keep track of the direction of the sort.
    $order = $query->orderby[0]['direction'] ?: 'ASC';

    // Get rid of the original sort handlers and order by clauses that may be
    // present in the view.
    $query->orderby = [];
    foreach ($display->getHandlers('sort') as $sort_handler) {
      $sort_handler->destroy();
    }

    // Inject freshly initialized sort handlers for the first name and last name
    // into the display.
    $display->handlers['sort'] = array_map(function ($info) use ($view, $display) {
      $handler = Views::handlerManager('sort')->getHandler($info, NULL);
      $handler->init($view, $display, $info);
      return $handler;
    }, joinup_group_get_og_members_overview_sort_handlers_info($order));

    // Make sure the sort handlers are "built". This is making sure that the
    // various references to objects and arrays are present at the places that
    // Views expects them to be.
    $view->_build('sort');
  }
}

/**
 * Returns info for Views sort handlers in the member administration form.
 *
 * We are overriding the username column in the member administration view so
 * that the full name (first name + last name) is shown. This means that we need
 * to override the sorting as well, since the usernames are not necessarily in
 * the same alphabetical order as the full names. This function returns the info
 * that can be used to create the Views sort handlers for the user's first and
 * last name.
 *
 * @param string $order
 *   The order in which to sort, either 'ASC' or 'DESC'.
 *
 * @return array
 *   An associative array of Views sort handler configuration options, keyed by
 *   field name.
 *
 * @see joinup_group_views_query_alter()
 */
function joinup_group_get_og_members_overview_sort_handlers_info(string $order): array {
  return [
    'field_user_first_name_value' => [
      'id' => 'field_user_first_name_value',
      'table' => 'user__field_user_first_name',
      'field' => 'field_user_first_name_value',
      'relationship' => 'uid',
      'group_type' => 'group',
      'admin_label' => '',
      'order' => $order,
      'exposed' => FALSE,
      'expose' => ['label' => ''],
      'plugin_id' => 'standard',
    ],
    'field_user_family_name_value' => [
      'id' => 'field_user_family_name_value',
      'table' => 'user__field_user_family_name',
      'field' => 'field_user_family_name_value',
      'relationship' => 'uid',
      'group_type' => 'group',
      'admin_label' => '',
      'order' => $order,
      'exposed' => FALSE,
      'expose' => ['label' => ''],
      'plugin_id' => 'standard',
    ],
    // Also sort by username so that the results are displayed in a consistent
    // order if the user has empty values for the first name and family name.
    // Our tests were exposing that having no ordering could cause bulk
    // operation actions to be taken on the wrong users.
    'name' => [
      'id' => 'name',
      'table' => 'users_field_data',
      'field' => 'name',
      'relationship' => 'uid',
      'group_type' => 'group',
      'admin_label' => '',
      'order' => $order,
      'exposed' => FALSE,
      'expose' => ['label' => ''],
      'plugin_id' => 'standard',
    ],
  ];
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function joinup_group_form_views_form_og_members_overview_default_alter(&$form, FormStateInterface $form_state, $form_id): void {
  if (!($group = \Drupal::routeMatch()->getParameter('rdf_entity')) || !$group instanceof GroupInterface) {
    throw new \RuntimeException('Called from a wrong page.');
  }

  /** @var \Drupal\Core\Action\ActionManager $action_manager */
  $action_manager = \Drupal::service('plugin.manager.action');
  /** @var \Drupal\joinup_group\Plugin\Action\TransferGroupOwnershipAction $plugin */
  $plugin = $action_manager->createInstance('joinup_transfer_group_ownership');

  // Allow the ownership to be transferred only by users with proper permission.
  if (!$plugin->canTransferOwnership($group, \Drupal::currentUser())) {
    unset($form['header']['og_membership_bulk_form']['action']['#options']['joinup_transfer_group_ownership']);
    return;
  }

  // Alter the action label in order to reflect the bundle of the group.
  $args = ['@label' => $group->get('rid')->entity->getSingularLabel()];
  $form['header']['og_membership_bulk_form']['action']['#options']['joinup_transfer_group_ownership'] = t('Transfer the ownership of the @label to the selected member', $args);
  $form['#validate'][] = 'joinup_group_form_views_form_og_members_overview_default_validate';

  // Hide the second 'Apply to selected items' button so that only the one from
  // the bulk form header remains.
  unset($form['actions']['submit']);
}

/**
 * Validation callback for the og_members_overview form.
 *
 * Prevents the deletion of memberships from a group if no owners will remain
 * after the deletion.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state object.
 */
function joinup_group_form_views_form_og_members_overview_default_validate(array &$form, FormStateInterface $form_state): void {
  if ($form_state->getValue('action') !== 'joinup_og_membership_delete_action') {
    return;
  }

  /** @var \Drupal\og\MembershipManagerInterface $membership_manager */
  $membership_manager = \Drupal::service('og.membership_manager');

  $group = \Drupal::routeMatch()->getParameter('rdf_entity');
  $owner_memberships = $membership_manager->getGroupMembershipsByRoleNames($group, ['administrator']);

  if (empty($owner_memberships)) {
    return;
  }

  $owner_membership_ids = array_keys($owner_memberships);

  // Calculate memberships to be deleted.
  $options = $form_state->getValue('og_membership_bulk_form');
  if (empty($options)) {
    return;
  }
  $memberships_to_be_deleted = array_map('joinup_group_extract_bulk_form_entity_id', array_filter($options));
  $left_owners = array_diff($owner_membership_ids, $memberships_to_be_deleted);
  if (empty($left_owners)) {
    $message = \Drupal::translation()->translate('You cannot delete the owner of a @type.', ['@type' => $group->bundle()]);
    $form_state->setError($form, $message);
  }
}

/**
 * Loads an entity based on a bulk form key.
 *
 * This derives from bulk form's way of loading row entities. Currently, it
 * exists in its simplified form as there is no need to deal with revisions or
 * languages. In the future, if the need emerges, this function can be extended
 * to match the original method.
 *
 * @param string $bulk_form_key
 *   The bulk form key representing the entity's ID, language.
 *
 * @see \Drupal\views\Plugin\views\field\BulkForm::loadEntityFromBulkFormKey
 *
 * @return string
 *   The entity's ID.
 */
function joinup_group_extract_bulk_form_entity_id(string $bulk_form_key): string {
  $key = base64_decode($bulk_form_key);
  $key_parts = json_decode($key);

  // The first two items will always be langcode and ID.
  return array_pop($key_parts);
}

/**
 * Generates and returns a shared link.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity related to the share link.
 * @param string $route
 *   The route to pass the share link in.
 *
 * @return array
 *   A link icon theme array.
 */
function joinup_group_generate_share_link(EntityInterface $entity, string $route): array {
  $url = Url::fromRoute($route, [$entity->getEntityTypeId() => $entity->id()]);

  return [
    '#theme' => 'link_icon',
    '#title' => t('Share'),
    '#icon' => 'share',
    '#url' => $url,
    '#attributes' => [
      'class' => ['use-ajax', 'action-link'],
      'data-dialog-type' => 'modal',
      'data-dialog-options' => Json::encode([
        'width' => 'auto',
        'height' => 'auto',
      ]),
    ],
    '#access' => $url->access(),
    '#attached' => ['library' => ['core/drupal.dialog.ajax']],
  ];
}

/**
 * Implements hook_ENTITY_TYPE_predelete().
 *
 * Mimic the og_entity_predelete function to delete the memberships of the user
 * before the user is deleted. The goal is to skip all notification attempts
 * related to the membership deletion.
 *
 * This workaround will prevent extra side loading and saving of entities.
 */
function joinup_group_user_predelete(EntityInterface $entity) {
  /** @var \Drupal\og\MembershipManagerInterface $membership_manager */
  $membership_manager = \Drupal::service('og.membership_manager');
  foreach ($membership_manager->getMemberships($entity->id(), []) as $membership) {
    $membership->skip_notification = TRUE;
    $membership->delete();
  }
}

/**
 * Implements hook_ENTITY_TYPE_update().
 *
 * Invalidates group membership list cache tags after a user is (un)blocked.
 *
 * If a user gets blocked in the entire site we no longer want to include this
 * user in the collection membership counts. We handle this use case here in
 * Joinup Core since Organic Groups currently only handles users that are
 * blocked on group level through the membership state; at this time OG is not
 * acting on users that are blocked on user level.
 */
function joinup_group_user_update(UserInterface $user) {
  // Only invalidate the tags if the user is being (un)blocked.
  if ($user->isBlocked() == $user->original->isBlocked()) {
    return;
  }

  /** @var \Drupal\og\MembershipManagerInterface $membership_manager */
  $membership_manager = \Drupal::service('og.membership_manager');
  $memberships = $membership_manager->getMemberships($user->id());

  $tags = [];
  foreach ($memberships as $membership) {
    if ($group = $membership->getGroup()) {
      $group_membership_list_cache_tags = Cache::buildTags(OgMembershipInterface::GROUP_MEMBERSHIP_LIST_CACHE_TAG_PREFIX, $group->getCacheTagsToInvalidate());
      $tags = Cache::mergeTags($tags, $group_membership_list_cache_tags);
    }
  }

  Cache::invalidateTags($tags);
}

/**
 * Implements hook_node_access_records().
 *
 * Creates access records for unpublished nodes that are group content, to allow
 * them to be viewed by group members with the 'view any unpublished content'
 * permission.
 */
function joinup_group_node_access_records(NodeInterface $node): array {
  /** @var \Drupal\joinup_group\JoinupGroupNodeAccessGrantsInterface $access_grants_helper */
  $access_grants_helper = \Drupal::service('joinup_group.node_access_grants');
  $grants = [];

  foreach ($node->getTranslationLanguages(TRUE) as $langcode => $language) {
    $translated_node = $node->getTranslation($langcode);
    if ($translated_node instanceof GroupContentInterface && !$translated_node->isPublished()) {
      try {
        $group = $translated_node->getGroup();
        $grants[] = [
          'realm' => 'joinup_group_view_unpublished',
          'gid' => $access_grants_helper->getNodeAccessGrantId($group),
          'grant_view' => 1,
          'grant_update' => 0,
          'grant_delete' => 0,
          'priority' => 0,
          'langcode' => $langcode,
        ];
      }
      catch (MissingGroupException $e) {
      }
    }
  }

  return $grants;
}

/**
 * Implements hook_node_grants().
 */
function joinup_group_node_grants(AccountInterface $account, string $op): array {
  $grants = [];

  if ($op === 'view') {
    /** @var \Drupal\og\MembershipManagerInterface $membership_manager */
    $membership_manager = \Drupal::service('og.membership_manager');
    /** @var \Drupal\joinup_group\JoinupGroupNodeAccessGrantsInterface $access_grants_helper */
    $access_grants_helper = \Drupal::service('joinup_group.node_access_grants');

    foreach ($membership_manager->getMemberships($account->id()) as $membership) {
      if ($membership->hasPermission('view any unpublished content')) {
        $group = $membership->getGroup();
        if ($group instanceof GroupInterface) {
          $grants['joinup_group_view_unpublished'][] = $access_grants_helper->getNodeAccessGrantId($group);
        }
      }
    }
  }

  return $grants;
}

/**
 * Implements hook_entity_update().
 */
function joinup_group_entity_update(EntityInterface $group): void {
  if ($group instanceof GroupInterface) {
    /** @var \Drupal\joinup_group\Entity\GroupInterface $group_original_entity */
    $group_original_entity = $group->original;
    if ($group_original_entity->getShortId() !== $group->getShortId()) {
      \Drupal::getContainer()->get('joinup_group.url_alias_updater')->queueGroupContent($group);
      $bundle_info = \Drupal::getContainer()->get('entity_type.bundle.info')->getBundleInfo($group->getEntityTypeId())[$group->bundle()];
      $arguments = [
        '@bundle' => $bundle_info['label_singular'],
        '%original' => $group_original_entity->getShortId(),
        '%actual' => $group->getShortId(),
      ];
      if ($group_original_entity->getShortId() && $group->getShortId()) {
        \Drupal::messenger()->addStatus(t("You've changed the @bundle's short ID from %original to %actual. It will take some time until the @bundle content URLs will be updated.", $arguments));
      }
      elseif (!$group_original_entity->getShortId()) {
        \Drupal::messenger()->addStatus(t("You've added a @bundle short ID: %actual. It will take some time until the @bundle content URLs will be updated.", $arguments));
      }
      elseif (!$group->getShortId()) {
        \Drupal::messenger()->addStatus(t("You've removed the @bundle's short ID: %original. It will take some time until the @bundle content URLs will be updated.", $arguments));
      }
    }
  }
}
