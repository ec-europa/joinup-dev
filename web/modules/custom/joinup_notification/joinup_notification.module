<?php

/**
 * @file
 * Module handling notifications in joinup.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Render\Markup;
use Drupal\joinup_notification\Event\NotificationEvent;
use Drupal\joinup_notification\NotificationEvents;

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function joinup_notification_node_insert(EntityInterface $entity) {
  joinup_notification_dispatch_notification('create', NotificationEvents::COMMUNITY_CONTENT_CRUD, $entity);
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 *
 * It is really hard to keep track of the from_state since state_machine does
 * not give us access to the initialValue protected property of the StateItem
 * class.
 *
 * Load the unchanged latest version and get the source state and save it to the
 * entity.
 *
 * This workaround comes because the $entity->original property points to the
 * latest published version instead of the latest revision.
 *
 * @see: https://www.drupal.org/node/2833084
 */
function joinup_notification_node_presave(EntityInterface $entity) {
  $bundles = ['document', 'discussion', 'event', 'news'];
  if ($entity->isNew() || !in_array($entity->bundle(), $bundles)) {
    return;
  }
  $entity->field_state_initial_value = $entity->get('field_state')->first()->getInitialValue();
}

/**
 * Implements hook_ENTITY_TYPE_update().
 */
function joinup_notification_node_update(EntityInterface $entity) {
  joinup_notification_dispatch_notification('update', NotificationEvents::COMMUNITY_CONTENT_CRUD, $entity);
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 */
function joinup_notification_node_delete(EntityInterface $entity) {
  joinup_notification_dispatch_notification('delete', NotificationEvents::COMMUNITY_CONTENT_CRUD, $entity);
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 *
 * During the hook_update, the entity is already saved. This renders impossible
 * to determine whether there was a published version before. Yet, the email
 * cannot be sent during the presave because the save action has not completed
 * yet and anything could go wrong. Thus, a property is set to define whether
 * the entity had a published version previously.
 */
function joinup_notification_rdf_entity_presave(EntityInterface $entity) {
  if ($entity->bundle() !== 'collection') {
    return;
  }

  if ($entity->isNew()) {
    $entity->hasPublished = FALSE;
  }
  else {
    $entity->hasPublished = $entity->hasGraph('default');
  }
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function joinup_notification_rdf_entity_insert(EntityInterface $entity) {
  joinup_notification_dispatch_notification('create', NotificationEvents::RDF_ENTITY_CRUD, $entity);
}

/**
 * Implements hook_ENTITY_TYPE_update().
 */
function joinup_notification_rdf_entity_update(EntityInterface $entity) {
  joinup_notification_dispatch_notification('update', NotificationEvents::RDF_ENTITY_CRUD, $entity);
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 */
function joinup_notification_rdf_entity_predelete(EntityInterface $entity) {
  joinup_notification_dispatch_notification('delete', NotificationEvents::RDF_ENTITY_CRUD, $entity);
}

/**
 * Dispatches a generic notification event.
 *
 * @param string $operation
 *   The CRUD operation string.
 * @param string $event_name
 *   The event name.
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity object.
 */
function joinup_notification_dispatch_notification($operation, $event_name, EntityInterface $entity) {
  // @todo Replace this direct access of a custom entity property with the
  //   temporary entity data API once it lands in core.
  // @see https://www.drupal.org/node/2896474
  if (isset($entity->skip_notification) && $entity->skip_notification === TRUE) {
    return;
  }
  $event = new NotificationEvent($operation, $entity);
  $event_dispatcher = \Drupal::getContainer()->get('event_dispatcher');
  $event_dispatcher->dispatch($event_name, $event);
}

/**
 * Implements hook_mail_alter().
 *
 * Converts in HTML the mails sent by the user and joinup_user modules.
 *
 * For emails sent by the message_notify module, add a prefix and a suffix.
 */
function joinup_notification_mail_alter(&$message) {
  if ($message['module'] === 'user' || $message['module'] === 'joinup_user') {
    $message['headers']['Content-Type'] = SWIFTMAILER_FORMAT_HTML;
    // Convert new lines to paragraphs and line breaks. Also transform the body
    // to markup.
    // @see swiftmailer_mail()
    $message['body'] = array_map(function ($text) {
      return Markup::create(_filter_autop($text));
    }, $message['body']);
  }

  // Mails sent by the message_notify module are already HTML ready.
  if ($message['module'] === 'message_notify') {
    $message['headers']['Content-Type'] = SWIFTMAILER_FORMAT_HTML;
    $user = user_load_by_mail($message['to']);
    $first_name = !empty($user->get('field_user_first_name')->value) ? $user->get('field_user_first_name')->value : 'Joinup user';
    $prefix = t('<p>Dear @first_name,</p>', ['@first_name' => $first_name]);
    $suffix = t('<p>Kind regards,</p><p>The Joinup Community Team</p>');
    $body = array_merge([$prefix], $message['body'], [$suffix]);
    $message['body'] = $body;
  }
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function joinup_notification_og_membership_insert(EntityInterface $entity) {
  joinup_notification_dispatch_notification('create', NotificationEvents::OG_MEMBERSHIP_MANAGEMENT, $entity);
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function joinup_notification_og_membership_presave(EntityInterface $entity) {
  if ($entity->isNew()) {
    return;
  }
  joinup_notification_dispatch_notification('update', NotificationEvents::OG_MEMBERSHIP_MANAGEMENT, $entity);
}

/**
 * Implements hook_ENTITY_TYPE_predelete().
 */
function joinup_notification_og_membership_predelete(EntityInterface $entity) {
  joinup_notification_dispatch_notification('delete', NotificationEvents::OG_MEMBERSHIP_MANAGEMENT, $entity);
}
