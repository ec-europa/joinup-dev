<?php

/**
 * @file
 * Contains \UserSubContext.
 */

use Behat\Gherkin\Node\TableNode;
use Drupal\comment\CommentInterface;
use Drupal\comment\Entity\Comment;
use Drupal\Core\Entity\EntityInterface;
use Drupal\DrupalExtension\Context\DrupalSubContextBase;
use Drupal\DrupalExtension\Context\DrupalSubContextInterface;
use Drupal\DrupalExtension\Hook\Scope\BeforeNodeCreateScope;
use Drupal\file\Entity\File;
use Drupal\joinup\Traits\BrowserCapabilityDetectionTrait;
use Drupal\joinup\Traits\NodeTrait;
use Drupal\joinup\Traits\OgTrait;
use Drupal\joinup\Traits\RdfEntityTrait;
use Drupal\joinup\Traits\UtilityTrait;
use Drupal\joinup\Traits\WorkflowTrait;
use Drupal\joinup\Traits\WysiwygTrait;
use Drupal\og\Og;
use Drupal\og\OgGroupAudienceHelperInterface;
use Drupal\search_api\Entity\Server;
use Drupal\User\Entity\User;

/**
 * Behat step definitions for testing users.
 */
class JoinupSubContext extends DrupalSubContextBase implements DrupalSubContextInterface {

  use BrowserCapabilityDetectionTrait;
  use NodeTrait;
  use OgTrait;
  use RdfEntityTrait;
  use UtilityTrait;
  use WorkflowTrait;
  use WysiwygTrait;

  /**
   * Test files.
   *
   * @var \Drupal\file\Entity\File[]
   */
  protected $files = [];

  /**
   * Test users.
   *
   * @var \Drupal\user\Entity\User[]
   */
  protected $registeredUsers = [];

  /**
   * Creates a user with data provided in a table.
   *
   * Table format:
   * | Username   | Mr Bond            |
   * | Password   | Bond007            |
   * | E-mail     | james.bond@mi5.org |
   *
   * @param TableNode $user_table
   *   The user data.
   *
   * @throws \Exception
   *   Thrown when a column name is incorrect.
   *
   * @Given (the following )user:
   */
  public function givenUser(TableNode $user_table) {
    $values = [];
    $aliases = self::userFieldAliases();
    // Replace the column aliases with the actual field names.
    foreach ($user_table->getRowsHash() as $key => $value) {
      if (array_key_exists($key, $aliases)) {
        $values[$aliases[$key]] = $value;
      }
      else {
        throw new \Exception("Unknown column '$key' in user table.");
      }
    }
    $this->handleFileFields($values, 'user', 'user');

    // Login method needs a password.
    if (!isset($values['pass'])) {
      $values['pass'] = $values['name'];
    }
    if (!isset($values['mail'])) {
      $values['mail'] = $values['name'] . '@example.com';
    }

    $user = (object) $values;
    $this->userCreate($user);
  }

  /**
   * Creates and authenticates a user with the given og role(s).
   *
   * Multiple roles can be passed separated with comma.
   *
   * @param string $roles
   *   A comma separated list of roles to assign to the user.
   * @param string $rdf_entity
   *   The label of the collection or solution of which the user is a member.
   * @param string $rdf_entity_bundle
   *   The RDF entity bundle, either 'collection' or 'solution'.
   *
   * @throws \Exception
   *   Thrown when a collection or solution with the given label doesn't exist.
   *
   * @Given I am logged in as a user with the :role role(s) of the :rdf_entity :rdf_entity_bundle
   * @Given I am logged in as a/an :role of the :rdf_entity :rdf_entity_bundle
   *
   * @see \Drupal\DrupalExtension\Context\DrupalContext::assertAuthenticatedByRole()
   */
  public function assertAuthenticatedByOgRole($roles, $rdf_entity, $rdf_entity_bundle) {
    $entity = $this->getRdfEntityByLabel($rdf_entity, $rdf_entity_bundle);
    if (!$entity) {
      throw new \Exception("No entity found with label $rdf_entity");
    }
    $roles = $this->explodeCommaSeparatedStepArgument($roles);
    $roles = $this->getOgRoles($roles, $entity);

    // Check if a user with this role is already logged in.
    if (!$this->loggedInWithOgRoles($roles, $entity)) {
      $random = $this->getRandom()->name(8);
      // Create user (and project)
      $user = (object) [
        'name' => $random,
        'pass' => $random,
      ];
      $user->mail = "{$user->name}@example.com";
      $this->userCreate($user);

      // Load the actual user account.
      $account = User::load($user->uid);
      $this->subscribeUserToGroup($account, $entity, $roles);

      // Login.
      $this->login($user);
    }
  }

  /**
   * Changes the role of a user within a collection or solution.
   *
   * Use this to e.g. test promotion or demotion of facilitators.
   *
   * @param string $rdf_entity
   *   The label of the collection or solution of which the user is a member.
   * @param string $rdf_entity_bundle
   *   The RDF entity bundle, either 'collection' or 'solution'.
   * @param string $roles
   *   A comma separated list of roles to assign to the user. All previously
   *   assigned roles will be discarded.
   *
   * @throws \Exception
   *   Thrown when a collection or solution with the given label doesn't exist.
   *
   * @Given my role(s) in the :rdf_entity :rdf_entity_bundle change(s) to :roles
   */
  public function updateGroupRoles($rdf_entity, $rdf_entity_bundle, $roles) {
    $entity = $this->getRdfEntityByLabel($rdf_entity, $rdf_entity_bundle);
    if (!$entity) {
      throw new \Exception("No entity found with label $rdf_entity");
    }
    $roles = $this->explodeCommaSeparatedStepArgument($roles);
    $roles = $this->getOgRoles($roles, $entity);

    $current_user = $this->getUserManager()->getCurrentUser();
    $account = User::load($current_user->uid);

    $this->subscribeUserToGroup($account, $entity, $roles);
  }

  /**
   * Checks that the logged in user has the given OG roles in the given group.
   *
   * If the user has more than the required roles, he might have permissions
   * from the rest of the roles that will lead the test to a false positive.
   * For this reason, we request check for the specific roles passed.
   *
   * @param \Drupal\og\Entity\OgRole[] $roles
   *   An array of roles to check.
   * @param \Drupal\Core\Entity\EntityInterface $group
   *   The group that is checked if the user has the role.
   *
   * @return bool
   *   Returns TRUE if the current logged in user has this role (or roles).
   *
   * @see \Drupal\DrupalExtension\Context\RawDrupalContext::loggedInWithRole
   */
  protected function loggedInWithOgRoles(array $roles, EntityInterface $group) {
    if ($this->getUserManager()->currentUserIsAnonymous() || !$this->loggedIn()) {
      return FALSE;
    }
    $current_user = $this->getUserManager()->getCurrentUser();
    $user = \Drupal::entityTypeManager()->getStorage('user')->loadUnchanged($current_user->uid);
    $membership = Og::getMembership($group, $user);
    if (empty($membership)) {
      return FALSE;
    }
    if ($roles == $membership->getRolesIds()) {
      return FALSE;
    }

    return TRUE;
  }

  /**
   * Save files and change filename into a file ID.
   */
  private function handleFileFields(&$values, $entity_type, $bundle) {
    $entity_manager = \Drupal::entityManager();
    /** @var \Drupal\Core\Field\FieldDefinitionInterface[] $fields */
    $fields = $entity_manager->getFieldDefinitions($entity_type, $bundle);

    foreach ($values as $field_name => $value) {
      if (!isset($fields[$field_name])) {
        throw new \Exception("Field $field_name is not set on entity $entity_type  : $bundle");
      }
      if (empty($value)) {
        continue;
      }
      /** @var \Drupal\Core\Field\FieldDefinitionInterface $field_info */
      $field_info = $fields[$field_name];
      if (in_array($field_info->getType(), ['image', 'file'])) {
        $files_path = $this->getMinkParameter('files_path');
        $path = rtrim(realpath($files_path), DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . $value;
        if (!is_file($path)) {
          throw new \Exception("File '$value' was not found in file path '$files_path'.");
        }
        // Copy the image into the public files folder and turn it into a File
        // entity before linking it.
        $uri = 'public://' . $value;
        file_unmanaged_copy($path, $uri);
        $file = File::create(['uri' => $uri]);
        $file->save();
        $values[$field_name] = $file->get('uri')->value;

        $this->files[$file->id()] = $file;
      }
    }
  }

  /**
   * Register a user.
   *
   * @Given the following user registration at :location:
   */
  public function submitRegistrationForm(TableNode $table, $location) {
    $this->visitPath($location);

    // Fill in fields.
    foreach ($table->getRowsHash() as $field => $value) {
      $this->getSession()->getPage()->fillField($field, $value);
      if ($field == 'Username') {
        $username = $value;
      }
    };
    // Submit form.
    $this->getSession()->getPage()->pressButton("Create new account");

    // Get the last registered user.
    $results = \Drupal::entityTypeManager()->getStorage('user')->loadByProperties(['name' => $username]);
    /** @var \Drupal\user\UserInterface $user */
    $user = reset($results);

    if ($user) {
      // Track user for auto delete in tear-down.
      $this->registeredUsers[$user->id()] = $user;
    }
    else {
      throw new Exception('User not registered.');
    }
  }

  /**
   * Remove any created registered users.
   *
   * @AfterScenario
   */
  public function cleanRegisteredUsers() {
    // Remove any users that were created.
    if (!empty($this->registeredUsers)) {
      /** @var \Drupal\user\Entity\User $user */
      foreach ($this->registeredUsers as $user) {
        $user->delete();
      }
    }
  }

  /**
   * Reset the request graphs of rdf entity before every step.
   *
   * The request graphs are tied to an individual request.
   *
   * @BeforeStep
   */
  public function resetRequestGraphs($event) {
    /** @var RdfEntitySparqlStorage $storage */
    $storage = \Drupal::entityTypeManager()->getStorage('rdf_entity');
    $storage->getGraphHandler()->resetRequestGraphs();
  }

  /**
   * Mapping of human readable names to machine names.
   *
   * @return array
   *    Field mapping.
   */
  private static function userFieldAliases() {
    return [
      'Username' => 'name',
      'Password' => 'pass',
      'E-mail' => 'mail',
      'Status' => 'status',
      'First name' => 'field_user_first_name',
      'Family name' => 'field_user_family_name',
      'Photo' => 'field_user_photo',
      'Business title' => 'field_user_business_title',
      'Organisation' => 'field_user_organisation',
      'Nationality' => 'field_user_nationality',
      'Professional domain' => 'field_user_professional_domain',
      // @todo Social network
    ];
  }

  /**
   * Checks that the given select field has the given options.
   *
   * To do this we extract the field text which contains the values expected
   * to be found in the select box as a concatenated string.
   * Then we check if the value is contained in the extracted value.
   *
   * @param string $select
   *    The name of the field element.
   * @param string $options
   *    The options to be checked separated by comma. Only labels are accepted.
   *
   * @throws Exception
   *    Throws an exception when a value does not exists.
   *
   * @Given (the ):select field has the :options option(s)
   */
  public function checkSelectOptions($select, $options) {
    $values = $this->getSession()->getPage()->findField($select)->getText();
    foreach (explode(',', $options) as $option) {
      if (strpos($values, trim($option)) === FALSE) {
        throw new \Exception("The option {$option} should exist in the {$select} field but was not found.");
      }
    }
  }

  /**
   * Checks if the given select field does not contain any of the given values.
   *
   * @param string $select
   *    The name of the field element.
   * @param string $options
   *    The options to be checked separated by comma.
   *
   * @throws Exception
   *    Throws an exception when a value exists.
   *
   * @Given (the ):select field does not have the :options option(s)
   */
  public function checkSelectOptionsInverse($select, $options) {
    $values = $this->getSession()->getPage()->findField($select)->getText();
    foreach (explode(',', $options) as $option) {
      if (strpos($values, trim($option)) !== FALSE) {
        throw new \Exception("The option {$option} should not exist in the {$select} field but was found.");
      }
    }
  }

  /**
   * Commit the solr index for testing purposes.
   *
   * @Then I commit the solr index
   */
  public function iCommitTheSolrIndex() {
    $search_servers = Server::loadMultiple();
    /** @var \Drupal\search_api\Entity\Server $search_server */
    foreach ($search_servers as $search_server) {
      $backend_id = $search_server->getBackendId();
      if (!$backend_id == 'search_api_solr') {
        continue;
      }
      /** @var \Drupal\search_api_solr\Plugin\search_api\backend\SearchApiSolrBackend $backend */
      $backend = $search_server->getBackend();
      /** @var \Drupal\search_api_solr\SolrConnectorInterface $connector */
      $connector = $backend->getSolrConnector();
      $update = $connector->getUpdateQuery();
      $update->addCommit(TRUE, TRUE);
      $connector->update($update);
    }
  }

  /**
   * Navigates to the edit page display of a node entity.
   *
   * @param string $bundle
   *   The type of the node entity.
   * @param string $title
   *   The title of the node.
   *
   * @When (I )go to the :bundle (content ) :title edit screen
   * @When (I )visit the :bundle (content ) :title edit screen
   */
  public function visitNodeEditForm($bundle, $title) {
    /** @var \Drupal\node\NodeInterface $node */
    $node = $this->getNodeByTitle($title, $bundle);
    $this->visitPath($node->url('edit-form'));
  }

  /**
   * Navigates to the canonical page display of a node page.
   *
   * This step is only to be used in scenario outlines.
   * If possible, use a specific page selector.
   *
   * @param string $type
   *   The type of the node entity.
   * @param string $title
   *   The name of the news page.
   *
   * @When (I )go to the content page of the type :type with the title :title
   * @When (I )visit the content page of the type :type with the title :title
   */
  public function visitNodePage($type, $title) {
    /** @var \Drupal\node\Entity\Node $node */
    $node = $this->getNodeByTitle($title, $type);
    $this->visitPath($node->url());
  }

  /**
   * Checks if a content entity is published.
   *
   * @param string $bundle
   *   The node bundle.
   * @param string $title
   *   The node title.
   *
   * @throws \Exception
   *   Throws an exception if the content is not published.
   *
   * @Then the :title :bundle (content )should be published
   */
  public function assertNodePublished($bundle, $title) {
    /** @var \Drupal\node\NodeInterface $node */
    $node = $this->getNodeByTitle($title, $bundle);
    if (!$node->isPublished()) {
      throw new \Exception("$title content should be published but it is not.");
    }
  }

  /**
   * Checks if a content entity is published.
   *
   * @param string $bundle
   *   The node bundle.
   * @param string $title
   *   The node title.
   *
   * @throws \Exception
   *   Throws an exception if the content is not published.
   *
   * @Then the :title :bundle (content )should not be published
   */
  public function assertNodeNotPublished($bundle, $title) {
    /** @var \Drupal\node\NodeInterface $node */
    $node = $this->getNodeByTitle($title, $bundle);
    if ($node->isPublished()) {
      throw new \Exception("$title content should not be published but it is.");
    }
  }

  /**
   * Checks if the given content entity has the correct number of revisions.
   *
   * @param string $bundle
   *   The node bundle.
   * @param string $title
   *   The node title.
   * @param int $count
   *   The expected number of revisions.
   *
   * @Then the :title :bundle (content )should have :count revision(s)
   */
  public function assertNodeRevisionCount($bundle, $title, $count) {
    /** @var \Drupal\node\NodeInterface $node */
    $node = $this->getNodeByTitle($title, $bundle);

    $revision_count = \Drupal::entityTypeManager()->getStorage('node')->getQuery()
      ->allRevisions()
      ->condition('nid', $node->id())
      ->count()
      ->execute();

    PHPUnit_Framework_Assert::assertEquals($count, $revision_count);
  }

  /**
   * Replaces human readable labels and values with their real counterparts.
   *
   * This allows us to:
   * - use human readable labels like 'short title' in test scenarios, and map
   *   them to the actual field names like 'field_document_short_title'.
   * - use human readable values such as a collection name instead of the URL
   *   that is actually used in the OG reference field.
   *
   * @param \Drupal\DrupalExtension\Hook\Scope\BeforeNodeCreateScope $scope
   *   An object containing the entity properties and fields that are to be used
   *   for creating the node as properties on the object.
   *
   * @BeforeNodeCreate
   */
  public static function massageFieldsBeforeNodeCreate(BeforeNodeCreateScope $scope) {
    $node = $scope->getEntity();

    // Replace field label aliases with the actual field names.
    foreach (get_object_vars($node) as $alias => $value) {
      $name = self::getNodeFieldNameFromAlias($node->type, $alias);
      if ($name !== $alias) {
        unset($node->alias);
        $node->$name = $value;
      }
    }

    // Replace collection and solution group references that use titles with the
    // actual URI. Note that this fails if a URI is supplied for a collection or
    // solution in a Behat test. This is by design, the URIs are not exposed to
    // end users of the site so they should not be used in BDD scenarios.
    if (!empty($node->{OgGroupAudienceHelperInterface::DEFAULT_FIELD})) {
      $entity = self::getRdfEntityByLabel($node->{OgGroupAudienceHelperInterface::DEFAULT_FIELD});
      $node->{OgGroupAudienceHelperInterface::DEFAULT_FIELD} = $entity->id();
    }

    // Replace the human readable publication statuses with the boolean values
    // that are expected by the Node module.
    if (!empty($node->status)) {
      $mapping = [
        'unpublished' => 0,
        'published' => 1,
      ];
      // Force the use of human readable values in Behat test scenarios, throw
      // an exception if the numeric values are used.
      if (!array_key_exists($node->status, $mapping)) {
        $supported_statii = implode(', ', array_keys($mapping));
        throw new \UnexpectedValueException("Unexpected status '{$node->status}'. Supported statuses are: $supported_statii.");
      }
      // Replace the human readable value with the expected boolean.
      $node->status = $mapping[$node->status];
    }
  }

  /**
   * Returns the actual field name for a given node field alias.
   *
   * @param string $type
   *   The node type for which to return the field name.
   * @param string $alias
   *   The human readable node field alias.
   *
   * @return string
   *   The actual field name, or the original string if the alias is not known.
   */
  protected static function getNodeFieldNameFromAlias($type, $alias) {
    $aliases = [
      'document' => [
        'short title' => 'field_document_short_title',
      ],
      'event' => [
        'short title' => 'field_event_short_title',
        'start date' => 'field_start_date',
      ],
      'news' => [
        'headline' => 'field_news_headline',
        'state' => 'field_news_state',
      ],
      'shared' => [
        'collection' => OgGroupAudienceHelperInterface::DEFAULT_FIELD,
        'solution' => OgGroupAudienceHelperInterface::DEFAULT_FIELD,
      ],
    ];

    // Check both the node type specific aliases as well as the shared aliases.
    foreach ([$type, 'shared'] as $key) {
      if (!empty($aliases[$key][$alias])) {
        return $aliases[$key][$alias];
      }
    }

    return $alias;
  }

  /**
   * Presses button with specified id|name|title|alt|value at a widget.
   *
   * Example: When I press "Log In" at "Fieldset"
   * Example: And I press "Log In" at "Custom widget".
   *
   * @When I press :button at( the) :fieldset( field)
   */
  public function pressButtonInFieldset($button, $fieldset) {
    // Fixes a step argument (with \\" replaced back to ")
    // @see: Behat\MinkExtension\Context\MinkContext::fixStepArgument
    $button = str_replace('\\"', '"', $button);
    $this->getSession()->getPage()->find('named', ['fieldset', $fieldset])->pressButton($button);
  }

  /**
   * Fills a date or time field at a datetime widget.
   *
   * Example: When I fill in "Start date" with the date "29-08-2016".
   * Example: When I fill in "Start date" with the time "26:59:00".
   *
   * @param string $field_group
   *    The field component's label.
   * @param string $field_name
   *    The field to be filled.
   * @param string $value
   *    The value of the field.
   *
   * @throws \Exception
   *    Thrown when more than one elements match the given field in the given
   *    field group.
   *
   * @When I fill in :field_group with the :field_name :value
   */
  public function fillDateField($field_group, $field_name, $value) {
    // Get the datetime fields and check which one of them has the label
    // provided. This is because datetime fields have use a complex widget and
    // render their title as a simple header, not as a label for the field.
    $field_selectors = $this->getSession()->getPage()->findAll('css', '.field--type-datetime');
    $field_selectors = array_filter($field_selectors, function ($field_selector) use ($field_group) {
      return $field_selector->has('named', ['content', $field_group]);
    });
    if (count($field_selectors) > 1) {
      throw new \Exception("More than one elements were found.");
    }
    $field_selector = reset($field_selectors);

    $field_selector->fillField(ucfirst($field_name), $value);
  }

  /**
   * Checks that the given node has the expected workflow state.
   *
   * @param string $title
   *   The title of the node to check.
   * @param string $type
   *   The node type.
   * @param string $state
   *   The expected state.
   *
   * @Then the :title :type content should have the :state state
   */
  public function assertNodeWorkflowState($title, $type, $state) {
    $node = $this->getNodeByTitle($title, $type);
    $actual = $this->getEntityStateField($node)->get('value')->getString();
    \PHPUnit_Framework_Assert::assertEquals($state, $actual, "The $title $type content has the expected state '$state' (actual: '$actual')");
  }

  /**
   * Checks if the given content belongs to the given parent rdf entity.
   *
   * If there are multiple entities or parents with the same title, then
   * only the first one is checked.
   *
   * @param string $parent
   *   The name of the parent.
   * @param string $parent_bundle
   *   The bundle of the parent.
   * @param string $content_bundle
   *   The bundle of the content.
   * @param string $content
   *   The title of the content.
   *
   * @Then the :parent :parent_bundle has a :content_bundle titled :content
   */
  public function assertContentOgMembership($parent, $parent_bundle, $content_bundle, $content) {
    $this->assertOgMembership($parent, $parent_bundle, $content, $content_bundle);
  }

  /**
   * Asserts the presence of a tile element with a certain heading.
   *
   * @param string $heading
   *   The heading of the tile.
   *
   * @throws \Exception
   *   Thrown when the expected tile is not found.
   *
   * @Given I (should )see the :heading tile
   */
  public function assertTilePresent($heading) {
    $results = $this->getSession()->getPage()->findAll('css', '.listing__item--tile .listing__title');
    foreach ($results as $result) {
      /** @var \Behat\Mink\Element\Element $result */
      if ($result->getText() === $heading) {
        return;
      }
    }

    throw new \Exception("The tile '$heading' was not found on the page");
  }

  /**
   * Asserts that there are no tile elements with a certain heading.
   *
   * @param string $heading
   *   The heading to search.
   *
   * @throws \Exception
   *   Thrown when a tile with the unwanted heading is found.
   *
   * @Given I (should )not see the :heading tile
   */
  public function assertTileNotPresent($heading) {
    $results = $this->getSession()->getPage()->findAll('css', '.listing__item--tile h2');
    foreach ($results as $result) {
      /** @var \Behat\Mink\Element\Element $result */
      if ($result->getText() === $heading) {
        throw new \Exception("The tile '$heading' was not found on the page");
      }
    }
  }

  /**
   * Assert that certain buttons are present on the page.
   *
   * @param string $buttons
   *    A comma separated list of button labels.
   *
   * @throws \Exception
   *   Thrown when an expected button is not present.
   *
   * @Then (the following )buttons should be present :buttons
   */
  public function assertButtonsVisible($buttons) {
    $buttons = $this->explodeCommaSeparatedStepArgument($buttons);

    $page = $this->getSession()->getPage();
    $not_found = [];
    foreach ($buttons as $button) {
      if (!$page->findButton($button)) {
        $not_found[] = $button;
      }
    }

    if (!empty($not_found)) {
      throw new \Exception('Button(s) expected, but not found: ' . implode(', ', $not_found));
    }
  }

  /**
   * Assert that certain buttons are not present on the page.
   *
   * @param string $buttons
   *    A comma separated list of button labels.
   *
   * @throws \Exception
   *   Thrown when an unexpected button is present.
   *
   * @Then (the following )buttons should not be present :buttons
   */
  public function assertButtonsNotVisible($buttons) {
    $buttons = $this->explodeCommaSeparatedStepArgument($buttons);

    $page = $this->getSession()->getPage();
    $found = [];
    foreach ($buttons as $button) {
      if ($page->findButton($button)) {
        $found[] = $button;
      }
    }

    if (!empty($found)) {
      throw new \Exception('Button(s) should not be present, but were found: ' . implode(', ', $found));
    }
  }

  /**
   * Click the given link in the plus button menu.
   *
   * On JavaScript enabled browsers this will first click the plus button to
   * open the menu.
   *
   * @param string $link
   *   The link text of the link to click.
   *
   * @When I click :link in the plus button menu
   */
  public function clickLinkInPlusButtonMenu($link) {
    // Check if we are running in an environment that supports JavaScript like
    // Selenium or PhantomJS. If this is the case the plus button menu will be
    // closed by default and needs to be opened first.
    $this->openPlusButtonMenu();
    $this->getSession()->getPage()->clickLink($link);
  }

  /**
   * Opens the plus button menu on JS-enabled browsers.
   */
  protected function openPlusButtonMenu() {
    if ($this->browserSupportsJavascript()) {
      $driver = $this->getSession()->getDriver();
      $this->getSession()->getDriver()->click('//div[contains(concat(" ", normalize-space(@class), " "), " add-content-menu ")]//button');

      // Wait for the menu opening animation to end before continuing.
      $end = microtime(TRUE) + 5;
      do {
        usleep(100000);
        // The plus button opening animation runs from the top right to the
        // bottom left. Wait for the last element to become visible to ensure
        // the menu is fully opened.
      } while (microtime(TRUE) < $end && !$driver->isVisible('//div[contains(concat(" ", normalize-space(@class), " "), " add-content-menu ")]//li[last()]'));
    }
  }

  /**
   * Enters the given text in the given WYSIWYG editor.
   *
   * If this is running on a JavaScript enabled browser it will first click the
   * 'Source' button so the text can be entered as normal HTML.
   *
   * @param string $text
   *   The text to enter in the WYSIWYG editor.
   * @param string $label
   *   The label of the field containing the WYSIWYG editor.
   *
   * @When I enter :text in the :label wysiwyg editor
   */
  public function enterTextInWysiwyg($text, $label) {
    // If we are running in a JavaScript enabled browser, first click the
    // 'Source' button so we can enter the text as HTML and get the same result
    // as in a non-JS browser.
    if ($this->browserSupportsJavascript()) {
      $this->pressWysiwygButton($label, 'Source');
      $this->setWysiwygText($label, $text);
    }
    else {
      $this->getSession()->getPage()->fillField($label, $text);
    }
  }

  /**
   * Create a comment.
   *
   * @Given comments:
   */
  public function createComments(TableNode $table) {
    foreach ($table->getColumnsHash() as $comment_values) {
      $query = \Drupal::entityQuery('node')
        ->condition('title', $comment_values['parent'])
        ->range(0, 1);
      $result = $query->execute();

      if (empty($result)) {
        throw new \InvalidArgumentException("Unable to load parent of comment.");
      }

      // Reload from database to avoid caching issues and get latest version.
      $id = reset($result);

      $query = \Drupal::entityQuery('user')
        ->condition('name', $comment_values['author'])
        ->range(0, 1);
      $result = $query->execute();
      $uid = reset($result);

      if (empty($result)) {
        throw new \InvalidArgumentException("Unable to load author of comment.");
      }
      unset($comment_values['parent']);
      unset($comment_values['author']);
      $comment_values['uid'] = $uid;
      $values = [
        'comment_type' => 'comment',
        'status' => CommentInterface::PUBLISHED,
        'uid' => $uid,
        'field_name' => 'field_comments',
        'entity_type' => 'node',
        'entity_id' => $id,
      ];
      $comment_values += $values;
      // Ignore due to conflicting Comment class in Phing.
      $comment = Comment::create($comment_values);
      $comment->save();
    }
  }

}
